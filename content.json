{"meta":{"title":"世纪小小孟","subtitle":"Always believe that something wonderful is about to happen","description":"生死看淡 不服就干","author":"孟庆国","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-11-25T14:38:47.000Z","updated":"2019-11-30T04:31:51.999Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-04-24T07:40:24.000Z","updated":"2019-12-05T11:11:45.779Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++类与对象","slug":"C++类与对象","date":"2019-11-29T14:19:46.000Z","updated":"2019-12-03T14:55:49.310Z","comments":true,"path":"2019/11/29/C++类与对象/","link":"","permalink":"http://yoursite.com/2019/11/29/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"说明：该篇文章是本人学习C++的学习记录，内容都是本人的独自理解。所以，内容难免会存在不严谨或理解上的偏差等现象，欢迎留言探讨。","text":"说明：该篇文章是本人学习C++的学习记录，内容都是本人的独自理解。所以，内容难免会存在不严谨或理解上的偏差等现象，欢迎留言探讨。 学习资料： 1.《C++面向对象程序设计教程(第三版)》 作者：陈维兴 林小茶 清华大学出版社 2.《C++语言程序设计(第四版)》 作者：郑莉 董渊 何江舟 清华大学出版社 面向对象程序设计的基本特点抽象抽象是指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以标书的过程。抽象包括两个方面：数据抽象、行为抽象 举例：对人进行抽象。 数据抽象：姓名(string name)、性别(string sex)、年龄(int age)等。行为抽象：行走 [ walk() ]、吃饭 [ eat() ]、睡觉 [ study() ] 等。 同一对象，由于侧重点不同可能会产生不同的抽象结果。 封装封装就是将抽象得到的数据和行为相组合，形成一个有机的整体——类，其中数据和函数(行为/功能)都是类的成员。 举例：将钟表封装成一个类。 1234567class Clock&#123; public: //外部接口，可在外部进行调用 void setTime(int newH,int newM,int newS); void showTime(); private: //私有成员，只能被内部方法所访问，外部无法直接访问 int hour,minute,second;&#125;; 封装使一部分成员作为外部接口，其他成员隐蔽起来，这样达到了对成员访问权限的合理控制，使不同类之间的相互影响减小到最低限度，增加数据的安全性。 继承思考：虽然对人进行了封装，但是人与人之间又是不同的，比如学生有学号、年级班级等数据以及青年大学习等行为，而老师有工号、讲师/教授/博导等称号以及教书育人等行为。这些不同对象拥有特有的数据和行为。 解决：C++提供一种类的继承的机制，允许程序员再保持原有类的特性的基础上，进行更具体、更详细的说明。 多态例如我们日常生活中所说的打架、打篮球、打酱油，虽然都是“打”，但是含义不同，动作不同。这就是多态性。重载函数就是一种多态的手段。 多态性是指一段程序能够处理多种类型对象的能力。 C++中，这种多态性可通过强制多态、重载多态、类型参数化多态、包含多态4种形式实现。 类和对象 类是对象的抽象，对象是类的实例。 类的声明先看一个栗子：下面是一个关于复数的类的定义： 123456789101112131415class Complex&#123; //关键字class声明名为Complex的类 double real; //数据成员，复数的实部 double imag; //数据成员，复数的虚部 // 成员函数 给数据成员赋初值 void init(double r,double i)&#123; real=r; imag=i; &#125; double abscomplex()&#123; double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; //注意这有个分号 类是一种数据类型，它是用户定义的一种抽象的数据类型。 编译下列代码： 1234567int main()&#123; Complex A; // 定义类的对象 A.init(1.1, 2.2); // 调用类的init方法赋初值 cout&lt;&lt;\"复数的绝对值是：\"&lt;&lt;A.abscomplex()&lt;&lt;endl; return 0;&#125;` 结果会出错： 错误之处在于，init()和abscomplex()是私有的。也就是说，在不说明类的成员是public(公有)还是private(私有)时，C++默认时私有的，也就是说外部不能直接访问。我们也可以看出，如果一个类中全部都是私有成员，那么这个类是没有任何用处的。 更改代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Complex&#123; // 关键字class声明名为Complex的类 private: //声明以下成员为私有 double real; //数据成员，复数的实部 double imag; //数据成员，复数的虚部 public: // 声明以下成员为共有 // 成员函数 给数据成员赋初值 void init(double r,double i)&#123; real=r; imag=i; &#125; double abscomplex()&#123; double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; //注意这有个分号int main()&#123; Complex A; // 定义类的对象 A.init(1.1, 2.2); // 调用类的init方法赋初值 cout&lt;&lt;\"复数的绝对值是：\"&lt;&lt;A.abscomplex()&lt;&lt;endl; // 调用abscomplex()方法求绝对值 return 0;&#125; 这样，外部就可以通过共有的方法简洁的访问类的成员。使得类内的私有成员变得更加安全。 运行结果： 说明：protected也是类成员的一个关键字，说明被保护成员，可由本类和派生类内的成员函数访问，其他访问是非法的。它是半隐蔽的。 成员函数的定义一般函数成员是公有的，习惯把共有成员写在前面，这样便于阅读。 在类内部定义函数(隐式声明)例如2.1中的例子一样定义函数就可以了。这种定义方式，C++编译器将函数作为内联函数处理。 在类外部定义函数首先要在类中声明函数原型，然后再在外部定义函数。 一般形式： 1234返回值类型 类名::成员函数名(参数表)&#123; 函数体&#125; 栗子： 123456789101112131415161718class Point&#123; public: void setpoint(int, int); // 声明成员函数 int getx(); // 声明函数 int gety(); // 声明函数 private: int x,y;&#125;;int Point::getx()&#123; return x;&#125;int Point::gety()&#123; return y;&#125;void Point::setpoint(int a, int b)&#123; x=a; y=b;&#125; 注意：Point::是必须写的。 采用这种定义方式是C++良好的类定义习惯，它可以减少类定义的长度，使阅读起来比较方便。 函数的显示定义就是在外部定义函数时，在函数最前面用inline声明成内联函数。 123inline int Point::getx()&#123; return x;&#125; 对象对象的定义定义一般形式： 123类名 对象1, 对象2, 对象3, ……;Point A,B; 类是一个模板，他不接收和存储数据，定义对象后，系统才会为对象分配对应的存储空间，用来存放对象总的成员。 对象中成员的访问通过对象选择符选择访问对象中的成员一般形式：对象名.数据成员或对象名.成员函数(实参表) 123Point op1;op1.setpoint(1,2); // 调用对象op1的成员函数给op1的数据成员赋值int i = op1.getx(); // 调用对象op1的成员函数取得x的值 通过指向对象的指针访问对象中的成员我们可以定义一个指针指向这个对象，则访问时使用-&gt;操作符： 1234567891011class Date&#123; public: int year;&#125;;int main()&#123; Date d, *p; // 定义了一个Date的对象的指针 p = &amp;d; // p指向对象d cout&lt;&lt; p-&gt;year &lt;&lt; endl;// 使用-&gt;访问成员year cout&lt;&lt; (*p).year &lt;&lt; endl; // 两者等价，因为*p就是对象d&#125; 通过引用访问对象成员1234567891011class Date&#123; public: int year;&#125;;int main()&#123; Date d; Date &amp;dd = d; // 定义d的引用 cout&lt;&lt;d.year; cout&lt;&lt;dd.year;&#125; dd是d的引用，所以dd与d占有相同的存储单元。 构造函数与析构函数在定义对象时，有时需要对数据成员进行初始化，这个任务由构造函数完成。 在特定对象使用结束后，还经常需要进行一些清理工作，这个任务由析构函数完成。 对象的初始化与构造函数类是一种抽象的数据类型，它不占存储空间，不能容纳具体数据，所以不能给数据成员赋初值。 所以下列程序是错误的。 1234class Date&#123; public: int year = 2019;&#125;; DEV-C++编译会出警告但是能运行，但是这种写法是错误的，最好不要使用，编程尽量按照规矩来，避免不同环境带来的奇怪的报错。 如果类种的所有成员都是共有的，则可以在定义对象时初始化数据成员。 1234567891011121314151617181920212223242526272829303132class Complex&#123; public: double real; double imag;&#125;;Complex c = &#123;1.1, 2.2&#125;;``` 如果成员是私有的，可以利用公有函数对对象中的数据成员赋初值：```c++class Complex&#123; public: void init(double ,double); double abscomplex(); private: double real; double imag;&#125;;void Complex::init(double a, duuble b)&#123; real = a; imag = b;&#125;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c; c.init(3.0, 4.0); cout&lt;&lt;c.abscomplex();&#125;// 运行结果：5 使用成员函数，给数据成员赋值，既不方便记忆也容易忘记，甚至会出错。所以，C++提供了构造函数来完成对象的初始化。 构造函数有以下特点： 必须与类同名 可以有任意类型的参数 不能具有返回值类型，void也不行 建立对象时自动执行 下面定义一个构造函数： 12345678910111213141516171819202122232425class Complex&#123; public: Complex(double r, double i)&#123; // 析构函数 real = r; imag = i; &#125; double abscomplex(); private: double real; double imag;&#125;;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c(3.0, 4.0); // 形式一 cout&lt;&lt; c.abscomplex() &lt;&lt; endl; Complex *p = new Complex(8.0,6.0); // 形式二 cout&lt;&lt; p-&gt;abscomplex() &lt;&lt;endl;&#125;/*运行结果：510*/ 将构造函数放在类外部定义： 123456789101112131415161718192021class Complex&#123; public: Complex(double r, double i); double abscomplex(); private: double real; double imag;&#125;;// 外部定义构造函数Complex::Complex(double r, double i)&#123; real = r; imag = i;&#125;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c(3.0, 4.0); cout&lt;&lt; c.abscomplex() &lt;&lt; endl;&#125;// 运行结构：5 在对构造函数做以下几点说明： 构造函数里面可以定义与初始化无关的操作，但是不提倡加入与初始化无关的操作。 构造函数一般声明为公有成员，但是它是在定义对象是自动调用的，而且只执行一次。像c.Complex(2.1,5.4)这种操作是非法的、错误的。 实际应用中，通常需要给每一个类都定义构造函数，如果没有定义的话，系统则会自动生成一个构造函数：Complex::Complex(){}。 可以没有形参。例如：Complex(){real = 0; image = 0;}。此时定义对象时Complex c，构造函数会被自动执行。 用成员初始化列表对数据成员初始化构造函数的另一种写法和调用方法。一般形式： 1234567构造函数名(形参表):数据成员1(初始化值1),数据成员2(初始化值2),……&#123; 构造函数体&#125;Complex(double r, double i):real(r), imag(i)&#123;&#125; 这种方法与普通的方法是有所区别的。普通构造函数是初始化数据成员是一种使用=的赋值操作，但是在C++中有些数据成员是不允许直接赋值的，例如const修饰的数据成员，或者是引用类型的数据成员，因此只能使用成员初始化列表对其初始化: 123456789101112131415161718192021222324252627class A&#123; public: A(int); // 声明原型函数 void print(); public: int x; int &amp;rx; const double pi; &#125;; A::A(int xx):x(xx), rx(x), pi(3.14)&#123;&#125; // 注意这里有一对花括号 void A::print()&#123; cout&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; cout&lt;&lt;\"rx=\"&lt;&lt;rx&lt;&lt;endl; cout&lt;&lt;\"pi=\"&lt;&lt;pi&lt;&lt;endl;&#125;int main()&#123; A a(7); a.print(); return 0;&#125;/*运行结果：x=7rx=7pi=3.14*/ 注意：使用该种方法初始化数据成员时，初始化顺序与成员初始化列表是没有关系的，是按照数据成员在类中声明的顺序初始化的。 123456789101112131415161718192021222324class A&#123; public: A(int); // 声明原型函数 void print(); public: int x; int y; &#125;; A::A(int xx):y(2*x),x(xx)&#123;&#125; // 注意这里有一对花括号 void A::print()&#123; cout&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl;&#125;int main()&#123; A a(7); a.print(); return 0;&#125;/*运行结果：x=7y=14*/ 建议使用成员初始化列表初始化数据成员，方便、简练。 构造函数的重载在C++，函数的重载是非常实用的，很多时候我们对不同的类型的数据进行相同的操作，就会用到重载。构造函数同样可以重载。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Date&#123; public: Date(); Date(int a, int b, int c); void print(); private: int year, month, day;&#125;; Date::Date():year(2019), month(12), day(3)&#123;&#125; // 初始化成默认数据Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2018, 12, 3); cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，初始成默认数据 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2018年12月3日d2: 2019年12月3日*/ 尽管一个类可以定义多个构造函数，但是创建一个对象时只会调用其中一个构造函数 带默认参数的构造函数构造函数允许带有默认参数，当创建对象时没有参数的传递就会使用默认参数。 12345678910111213141516171819202122232425262728class Date&#123; public: Date(int a=2018, int b=12, int c=3); //指定默认参数 void print(); private: int year, month, day;&#125;;// 在类外部创建构造函数时可以不再次指定默认参数值Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2019); // 调用时可以只指定部分参数 cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，使用默认参数 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2019年12月3日d2: 2018年12月3日*/ 说明： 一个类中如果定义了一个带有默认参数的构造函数，就不能再定义别的带有默认参数的构造函数或者是不带参数的构造函数。例如：Complex(double r=1.1, double i=2.2);Complex();如果存在这样两个构造函数的话，编译系统则不知道该调用哪个构造函数。 如下情况编译系统也无法判断应该调用哪个函数：Complex(double r=1.1, double i=2.2);Complex(double r); 析构函数析构函数执行与构造函数相反的操纵，通常用来执行一些清洗工作，如释放分配给对象的空间等。它有以下特点： 析构函数名与类名相同 析构函数不具有任何返回值，不能说明它的类型 析构函数没有参数，不能重载 撤销对象时，系统自动调用析构函数 123456789101112131415161718192021222324252627282930313233class Date&#123; public: Date(int a=2018, int b=12, int c=3); //带有默认参数 ~Date(); //声明析构函数 void print(); private: int year, month, day;&#125;;Date::~Date()&#123; // 析构函数 内部可以写程序体 cout&lt;&lt;\"清洗完毕\"&lt;&lt;endl; &#125;Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2019); cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，使用默认参数 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2019年12月3日d2: 2018年12月3日清洗完毕清洗完毕*/ 可以看出，当对象的生命周期结束时，系统将自动调用析构函数，清洗对象的存储空间。 如果没有定义析构函数，系统会默认定义Date::~Date(){}作为类的析构函数。一般情况下系统自动定义的析构函数足以满足需要。 但是，当在清理对象之前还需要做一些操作的话，则需要自己定义析构函数。","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"类与对象","slug":"class-object","permalink":"http://yoursite.com/tags/class-object/"}]},{"title":"慕课评论爬虫","slug":"慕课评论爬虫","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-27T13:04:42.986Z","comments":true,"path":"2019/11/21/慕课评论爬虫/","link":"","permalink":"http://yoursite.com/2019/11/21/%E6%85%95%E8%AF%BE%E8%AF%84%E8%AE%BA%E7%88%AC%E8%99%AB/","excerpt":"看文件看到了今年暑假写的爬虫代码，当时要做数据分析才去学的爬虫。本来对爬虫挺好奇的，但是学了一点之后就没什么兴趣了，特别是看scrapy爬虫框架，我看了连两天没有看明白，笨拙的我果断放弃了scrapy。对于那些动态网页，我就直接采用selenium进行网页加载和模拟点击翻页操作，虽然速度慢，但是对我来说可以问题不大。 毕竟咱也不是做爬虫的，用的时候能爬出来数据就好了。","text":"看文件看到了今年暑假写的爬虫代码，当时要做数据分析才去学的爬虫。本来对爬虫挺好奇的，但是学了一点之后就没什么兴趣了，特别是看scrapy爬虫框架，我看了连两天没有看明白，笨拙的我果断放弃了scrapy。对于那些动态网页，我就直接采用selenium进行网页加载和模拟点击翻页操作，虽然速度慢，但是对我来说可以问题不大。 毕竟咱也不是做爬虫的，用的时候能爬出来数据就好了。 今天看到以前写的代码，觉得以后可能会需要用到爬虫爬点数据啥的，所以有必要把代码保留好，毕竟两个月没写过爬虫我都忘了怎么写的了。爬的是慕课上面一门课程的评论： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import timeimport reimport pandas as pdfrom bs4 import BeautifulSoupfrom selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Bydef comment(url,n): driver=webdriver.PhantomJS() driver.get(url) soup=BeautifulSoup(driver.page_source,'lxml') # 点击‘课程评价’ evaluation_click=WebDriverWait(driver,10).until(EC.element_to_be_clickable((By.CSS_SELECTOR,'#review-tag-button'))) evaluation_click.click() # 等待加载评论 time.sleep(2) soup=BeautifulSoup(driver.page_source,'lxml') # 抓取课程总评分 score=soup.select('div.ux-mooc-comment-course-comment_head_rating-scores &gt; span')[0].text print('课程总评分：',score) # 抓取评论人数 comment_number=re.findall('\\d+',soup.select('#review-tag-num')[0].text)[0] print('评论次数',comment_number) print('------------------------') comments=[] # 评论 points = [] # 评分 p_time = [] # 发表时间 c_time = [] # 对应课时 like_num=[] # 点赞人数 stu_id = [] # 抓取单独个人的评价内容、评分、评论点赞数、发布时间、对应课时 # --------------------------循环开始---------------------------- for n in range(1,n+1): # 抓取学生id stu_name=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_user-info &gt; a') stu_id.append([re.findall('\\d+',x.get('href'))[1] for x in stu_name]) # 爬取评论内容 comment=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_content &gt; span') list_=[] for k in comment: list_.append(k.text) comments.append(list_) # 爬取发表时间 public_time=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_time') list_=[] for k in public_time: list_.append(k.text) p_time.append(list_) # 爬取评论对应开课次数 class_time=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_term-sign') list_=[] for k in class_time: list_.append(k.text) c_time.append(list_) # 爬取点赞次数 like_number=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_actions &gt; span &gt; span &gt; span:nth-of-type(2)') list_=[] for k in like_number: list_.append(k.text) like_num.append(list_) # 抓取评分 goal=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_user-info &gt; span &gt; div &gt; div.star-point') point_list=[] for i in goal: point_list.append(len(i.select('i'))) points.append(point_list) # 点击‘下一页’，继续加载评论内容 next_page=WebDriverWait(driver,10).until(EC.element_to_be_clickable((By.CSS_SELECTOR,'li.ux-pager_btn.ux-pager_btn__next &gt; a'))) next_page.click() # 模拟点击与解析页面之间添加sleep，避免爬去重复页面 time.sleep(2) # 解析当前页面 soup=BeautifulSoup(driver.page_source,'lxml') print('已爬取%d页内容！'%n) # -----------------------结束循环----------------------- driver.close() # 整理所得结果，使之成为一维列表 points=[x for i in points for x in i] like_num=[x for i in like_num for x in i] c_time=[x for i in c_time for x in i] p_time=[x for i in p_time for x in i] comments=[x for i in comments for x in i if x!='更多'] stu_id=[x for i in stu_id for x in i] # 存储结果为DataFrame形式 return pd.DataFrame(&#123; '学生ID':stu_id, '评论':comments, '评分':points, '发布时间':p_time, '对应课时':c_time, '点赞人数':like_num &#125;)url='https://www.icourse163.org/course/BIT-1001870001'n=85df=comment(url,n) 结果：","categories":[{"name":"爬虫","slug":"crawler","permalink":"http://yoursite.com/categories/crawler/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"crawler","permalink":"http://yoursite.com/tags/crawler/"}]},{"title":"分治算法-棋盘覆盖问题","slug":"分治算法-棋盘覆盖问题","date":"2019-11-15T16:00:00.000Z","updated":"2019-11-29T05:34:55.958Z","comments":true,"path":"2019/11/16/分治算法-棋盘覆盖问题/","link":"","permalink":"http://yoursite.com/2019/11/16/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/","excerpt":"最近老师给我们布置了一道OJ题目，是关于分治算法的，觉得很有意思，也自己琢磨出了解题代码，就来记录一下。","text":"最近老师给我们布置了一道OJ题目，是关于分治算法的，觉得很有意思，也自己琢磨出了解题代码，就来记录一下。 题目题目: 分治思路直接看这篇文章就好了，有图可以帮助理解。 代码代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;int qp[64][64];int qz=1;void fun(int th,int tl,int qh,int jh,int qsl,int jzl)&#123; // th/tl-特殊位置 qh/jh-起始行/截至行 qsl/jzl-起始列/截至列 int zsh,zsl,ysh,ysl,zxh,zxl,yxh,yxl; //记录每个分治的特殊位置：左上 右上 左下 右下 float x,y; //坐标原点 x=float(qh+jh)/2; y=float(qsl+jzl)/2; //判断特殊点在第几象限 if(float(th)&lt;x &amp;&amp; float(tl)&lt;y)&#123; //第一象限 左上 qp[int(x+0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qp[int(x-0.5)][int(y+0.5)]=qz++; //记录每个分治的特殊位置 zsh=th;zsl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zxh=int(x+0.5);zxl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&lt;x &amp;&amp; float(tl)&gt;y)&#123; //第二象限 右上 qp[int(x-0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qp[int(x+0.5)][int(y-0.5)]=qz++; ysh=th;ysl=tl; zsh=int(x-0.5);zsl=int(y-0.5); zxh=int(x+0.5);zxl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&gt;x &amp;&amp; float(tl)&lt;y)&#123; //第三象限 左下 qp[int(x-0.5)][int(y+0.5)]=qp[int(x-0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qz++; zxh=th;zxl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zsh=int(x-0.5);zsl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&gt;x &amp;&amp; float(tl)&gt;y)&#123; //第四象限 右下 qp[int(x+0.5)][int(y-0.5)]=qp[int(x-0.5)][int(y-0.5)]=qp[int(x-0.5)][int(y+0.5)]=qz++; yxh=th;yxl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zxh=int(x+0.5);zxl=int(y-0.5); zsh=int(x-0.5);zsl=int(y-0.5); &#125; if(qh+1==jh) return; //分治结束 //递归左上分治 fun(zsh,zsl,qh,(qh+jh)/2,qsl,(qsl+jzl)/2); //递归右上分治 fun(ysh,ysl,qh,(qh+jh)/2,(qsl+jzl)/2+1,jzl); //递归左下分治 fun(zxh,zxl,(qh+jh)/2+1,jh,qsl,(qsl+jzl)/2); //递归右下分治 fun(yxh,yxl,(qh+jh)/2+1,jh,(qsl+jzl)/2+1,jzl);&#125; int main()&#123; int N,n,row,col,i,j,k=1; cin&gt;&gt;N; while(N--)&#123; qz=1; cin&gt;&gt;n&gt;&gt;row&gt;&gt;col; fun(row,col,0,n-1,0,n-1); cout&lt;&lt;\"CASE:\"&lt;&lt;k++&lt;&lt;\"\\n\"; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(j!=n-1) cout&lt;&lt;qp[i][j]&lt;&lt;\"\\t\"; else cout&lt;&lt;qp[i][j]; &#125; cout&lt;&lt;\"\\n\"; &#125; &#125;&#125; 再放两个别人的代码： 因为我头脑简单，所以觉得自己的代码比别人的好懂(没人家的高级，嘿嘿)。以下别人的代码来自这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;int tile=1; //L型骨牌的编号(递增)int board[100][100]; //棋盘/****************************************************** 递归方式实现棋盘覆盖算法* 输入参数：* tr--当前棋盘左上角的行号* tc--当前棋盘左上角的列号* dr--当前特殊方格所在的行号* dc--当前特殊方格所在的列号* size：当前棋盘的:2^k*****************************************************/void chessBoard ( int tr, int tc, int dr, int dc, int size )&#123; if ( size==1 ) //棋盘方格大小为1,说明递归到最里层 return; int t=tile++; //每次递增1 int s=size/2; //棋盘中间的行、列号(相等的) //检查特殊方块是否在左上角子棋盘中 if ( dr&lt;tr+s &amp;&amp; dc&lt;tc+s ) //在 chessBoard ( tr, tc, dr, dc, s ); else //不在，将该子棋盘右下角的方块视为特殊方块 &#123; board[tr+s-1][tc+s-1]=t; chessBoard ( tr, tc, tr+s-1, tc+s-1, s ); &#125; //检查特殊方块是否在右上角子棋盘中 if ( dr&lt;tr+s &amp;&amp; dc&gt;=tc+s ) //在 chessBoard ( tr, tc+s, dr, dc, s ); else //不在，将该子棋盘左下角的方块视为特殊方块 &#123; board[tr+s-1][tc+s]=t; chessBoard ( tr, tc+s, tr+s-1, tc+s, s ); &#125; //检查特殊方块是否在左下角子棋盘中 if ( dr&gt;=tr+s &amp;&amp; dc&lt;tc+s ) //在 chessBoard ( tr+s, tc, dr, dc, s ); else //不在，将该子棋盘右上角的方块视为特殊方块 &#123; board[tr+s][tc+s-1]=t; chessBoard ( tr+s, tc, tr+s, tc+s-1, s ); &#125; //检查特殊方块是否在右下角子棋盘中 if ( dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s ) //在 chessBoard ( tr+s, tc+s, dr, dc, s ); else //不在，将该子棋盘左上角的方块视为特殊方块 &#123; board[tr+s][tc+s]=t; chessBoard ( tr+s, tc+s, tr+s, tc+s, s ); &#125;&#125;void main()&#123; int size; cout&lt;&lt;\"输入棋盘的size(大小必须是2的n次幂): \"; cin&gt;&gt;size; int index_x,index_y; cout&lt;&lt;\"输入特殊方格位置的坐标: \"; cin&gt;&gt;index_x&gt;&gt;index_y; chessBoard ( 0,0,index_x,index_y,size ); for ( int i=0; i&lt;size; i++ ) &#123; for ( int j=0; j&lt;size; j++ ) cout&lt;&lt;board[i][j]&lt;&lt;\"/t\"; cout&lt;&lt;endl; &#125;&#125; 2. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;const int N = 11;int Board[N][N];int tile = 0; /*tr:棋盘左上角方格的行号tc:棋盘左上角方格的列号dr:特殊方格所在的行号dc:特殊方格所在的列号size:方形棋盘的边长*/void ChessBoard(int tr, int tc, int dr, int dc, int size)&#123; if(size == 1) return; int t = ++tile, s = size/2; //覆盖左上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s) //特殊方格在此棋盘中 ChessBoard(tr, tc, dr, dc, s); else // 此棋盘无特殊方格 &#123; // 用t号L型骨型牌覆盖右下角 Board[tr+s-1][tc+s-1] = t; // 覆盖其余方格 ChessBoard(tr, tc, tr+s-1, tc+s-1, s); &#125; //覆盖右上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&gt;=tc+s) ChessBoard(tr, tc+s, dr, dc, s); else &#123; Board[tr+s-1][tc+s] = t; ChessBoard(tr, tc+s, tr+s-1, tc+s, s); &#125; //覆盖左下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&lt;tc+s) ChessBoard(tr+s, tc, dr, dc, s); else &#123; Board[tr+s][tc+s-1] = t; ChessBoard(tr+s, tc, tr+s, tc+s-1, s); &#125; //覆盖右下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s) ChessBoard(tr+s, tc+s, dr, dc, s); else &#123; Board[tr+s][tc+s] = t; ChessBoard(tr+s, tc+s, tr+s, tc+s, s); &#125;&#125; void DisplayBoard(int size)&#123; for(int i=1; i&lt;=size; ++i) &#123; for(int j=1; j&lt;=size; ++j) printf(\"%2d \", Board[i][j]); printf(\"\\n\"); &#125;&#125; int main()&#123; ChessBoard(1, 1, 1, 2, 4); DisplayBoard(4); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"分治算法","slug":"fenzhi","permalink":"http://yoursite.com/tags/fenzhi/"},{"name":"棋盘覆盖","slug":"qipanfugai","permalink":"http://yoursite.com/tags/qipanfugai/"},{"name":"数据结构","slug":"DataStructure","permalink":"http://yoursite.com/tags/DataStructure/"}]},{"title":"TensorFlow2.0图片数据读取","slug":"TensorFlow2.0读取图片数据","date":"2019-11-14T16:00:00.000Z","updated":"2019-12-02T04:50:01.069Z","comments":true,"path":"2019/11/15/TensorFlow2.0读取图片数据/","link":"","permalink":"http://yoursite.com/2019/11/15/TensorFlow2.0%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE/","excerpt":"最近TensorFlow2.0正式发布，而且把Keras合并成为了TensorFlow2.0的一个高级API，这操作简直是爽啊。然后我就屁跌儿屁跌儿的去学TensorFlow了，想着搭建一个图片分类器玩玩。调用tf.Keras简直不要太爽啊，搭好神经网络之后我开始读点图片测试程序能不能跑通。刚打开文件我才意识到，读图片跟读文本、表格不一样，我就赶紧看TensorFlow2.0的中文文档还有其他百度的方法，这一看就是三四天，太折磨人了。","text":"最近TensorFlow2.0正式发布，而且把Keras合并成为了TensorFlow2.0的一个高级API，这操作简直是爽啊。然后我就屁跌儿屁跌儿的去学TensorFlow了，想着搭建一个图片分类器玩玩。调用tf.Keras简直不要太爽啊，搭好神经网络之后我开始读点图片测试程序能不能跑通。刚打开文件我才意识到，读图片跟读文本、表格不一样，我就赶紧看TensorFlow2.0的中文文档还有其他百度的方法，这一看就是三四天，太折磨人了。 最后我放弃了文档和百度，自己看tf自带的数据集加载之后的type和shape，然后我发现图片数据加载完之后的类型是array形状是(60000,28,28),形状的是一个四维向量，分别是：(样本量，图片长度，图片宽度，图片通道数)，因为我看的是Mnist数据集，它的图片是一个channels=1的图片，所以shape没有最后第四维。通过观察这些特征之后我就自己使用numpy、os库自己尝试着把数据加载组合成这样的type和shape，代码如下： 12345678910111213141516171819202122232425262728293031# 加载图片def imgfun(fn): image_string = tf.io.read_file(fn) image_decoded = tf.image.decode_jpeg(image_string,channels=3) image_resized = tf.image.resize(image_decoded, [200, 200]) / 255.0 image = np.array(image_resized).tolist() return image# 处理图片def process_img(pdir_1,pdir_2,n1,n2): pathdir_1 = os.listdir(pdir_1) # 根目录 pathdir_2 = os.listdir(pdir_2) # 路径合并 paths = [pdir_1 + path for path in pathdir_1] paths.extend([pdir_2 + path for path in pathdir_2]) # 合并形成完整图片路径 # 添加标签 labels = [n1]*len(pathdir_1) # label n1 stand for 1 labels.extend([n2]*len(pathdir_2)) # label n2 stand for 2 # 打乱数据集 img_data = zip(paths,labels) # 合并路径和标签 img_data = np.array(list(img_data)) # np.array型可调用shuffle方法进行打乱 np.random.shuffle(img_data) # 打乱 path = [x[0] for x in img_data] # 提取图片路径 label = np.array([x[1] for x in img_data],dtype=int) # 提取对应的图片标签，标签为int类型 img = np.array(list(map(imgfun,path))) # 调用imgfun函数提取图片数据并转化成array形式 return img,label 上述代码运行结果： 在上面代码中我遇到一个map函数，刚开始发现它返回的是一个迭代器类型，我遍历一遍之后再次遍历发现就没有输出结果了，我百度之后get到了一个新的知识点： map函数在python.2.xxx中返回的是一个列表，在python.3.xxx中返回的是一个迭代器。迭代器遍历一次之后里面的元素就没有了。 就像这样：","categories":[{"name":"深度学习","slug":"deep-learning","permalink":"http://yoursite.com/categories/deep-learning/"}],"tags":[{"name":"深度学习","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"},{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"http://yoursite.com/tags/TensorFlow2-0/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"图像","slug":"image","permalink":"http://yoursite.com/tags/image/"},{"name":"数据读取","slug":"readdata","permalink":"http://yoursite.com/tags/readdata/"}]}]}