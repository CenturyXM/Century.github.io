{"meta":{"title":"世纪小小孟","subtitle":"Always believe that something wonderful is about to happen","description":"生死看淡 不服就干","author":"孟庆国","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-12-05T11:27:02.870Z","updated":"2019-12-05T11:27:02.870Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-12-05T11:21:51.628Z","updated":"2019-12-05T11:21:51.628Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"动态规划0-1背包问题","slug":"动态规划0-1背包问题","date":"2020-03-08T07:55:44.000Z","updated":"2020-03-08T08:12:52.699Z","comments":true,"path":"2020/03/08/动态规划0-1背包问题/","link":"","permalink":"http://yoursite.com/2020/03/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%920-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"动态规划通常应用于最优化问题，即要做出一组选择以达到一个最优解。在做选择的同时，经常出现同样形式的问题。当某一特定的子问题可能出自于多于一种选择的集合时，动态规划是很有效的；关键技术是存储这些子问题每一个的解，以备它重复出现。","text":"动态规划通常应用于最优化问题，即要做出一组选择以达到一个最优解。在做选择的同时，经常出现同样形式的问题。当某一特定的子问题可能出自于多于一种选择的集合时，动态规划是很有效的；关键技术是存储这些子问题每一个的解，以备它重复出现。 问题描述有N件物品和一个容量为V的背包。第i件物品的价值是c[i]，重量是w[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。每种物品只有一件，可以选择放或者不放。 构建亿个具体实例：设有一个容量V为20的背包，有N=5件物品，它们的价值重量如下：|序号i|重量w|价值v|| — | – | – ||1|2|3||2|3|4||3|4|5||4|5|8||5|9|10|求：求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。每种物品只有一件，可以选择放或者不放。 为题分析设变量V[i, j]表示在背包容量为j的前提下，装前i个物品的最大价值。那么针对V[i,j]我们先考虑第5件物品要不要装，有两种情况：第5件物品的重量大于背包的容量 w[i]&gt;j和第5件物品的重量小于等于背包容量 w[i]&lt;=j。而第二种情况又可以分为两种情况：装和不装，那么我们肯定选择其中一种使得V[i,j]最优。 下面探索求解公式： w[i]&gt;j：第i件物品无法装配，那么容量j不变，价值不变，下面需要从前i-1件物品里求解，那么该种情况下原问题就变成了V[i,j]=V[i-1,j] w[i]&lt;=j 装：装下第i件商品，容量减少w[i]，但是价值增加了v[i]，再向上求解就变成了V[i-1,j-w[i]]，此时V[i,j]=V[i-1,j-w[i]]+v[i]w[i]&lt;=j 不装：容量价值都没有变化，但是再向上求解是从i-1件物品中，此时V[i,j]=V[i-1,j]从装与不装中选择最大值，即是V[i,j]=max{V[i-1,j-w[i]]+v[i], V[i-1,j]} 总结出V[i,j]的递归求解公式为： 我们发现，原问题分解的子问题也都是子问题的最优解，所以满足最优子结构性质。对于每个子问题的解，我们使用二维数组表示，解决了重复计算重叠子问题的问题。 代码实现1234567891011121314151617181920212223242526272829303132333435def find(a,b,V,w,v): items = list() def findItem(i,j): # 回溯找到装入的物品 if i&gt;0: if V[i][j]==V[i-1][j]: # 第i个物品没有装,包括w[i]&gt;j和能装但是没装这两种情况 findItem(i-1,j) # 那么回溯到i-1个物品 elif (w[i]&lt;=j) &amp; (V[i][j]==V[i-1,j-w[i]]+v[i]): # 装了 items.append(i) # 记录 findItem(i-1, j-w[i]) # 回溯，容量减少 findItem(a,b) return itemsdef main(): import numpy as np C = int(input(\"背包容量：\")) N = int(input(\"物品数量：\")) w, v, items=[0], [0], [] # items记录装入物品的序号 V = np.zeros((N+1, C+1)).astype(\"int64\") # 使用np.array或者使用循环初始化二维列表，避免浅拷贝 for i in range(N): # 构建重量和价值列表 w.append(int(input(f\"第&#123;i+1&#125;个物品的重量：\"))) v.append(int(input(f\"第&#123;i+1&#125;个物品的价值：\"))) # 根据公式构建动态规划表 for i in range(1,N+1): for j in range(1,C+1): if w[i]&gt;j: V[i][j] = V[i-1][j] else: V[i][j] = max(V[i-1][j], V[i-1][j-w[i]]+v[i]) print('\\n',V) # 回溯寻找装入物品的序号 print('装入的物品序号为：',find(N,C,V,w,v)[::-1])main()","categories":[{"name":"算法","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"http://yoursite.com/tags/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"IEEE754标准下的32位浮点数","slug":"IEEE754标准下的32位浮点数","date":"2020-02-27T01:11:20.000Z","updated":"2020-02-27T02:03:41.205Z","comments":true,"path":"2020/02/27/IEEE754标准下的32位浮点数/","link":"","permalink":"http://yoursite.com/2020/02/27/IEEE754%E6%A0%87%E5%87%86%E4%B8%8B%E7%9A%8432%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"这学期开了计算机组成原理这门课，第二周学习的浮点数表示时对IEEE754标准有点小懵逼。主要是思想还停留在十进制的世界里，而且没有搞懂为什么阶码偏移值是127。","text":"这学期开了计算机组成原理这门课，第二周学习的浮点数表示时对IEEE754标准有点小懵逼。主要是思想还停留在十进制的世界里，而且没有搞懂为什么阶码偏移值是127。 认识IEEE754单精度浮点数IEEE754浮点数由符号位S、阶码部分E、位数部分M组成。单精度浮点数具体形式如下： 关于阶码字段E，采用偏移值为127的移码表示(为什么采用127下面等会再讲)。 关于位数M，在IEEE754中约定小数点左边隐含一位1，即有效位数是24位，完整尾数形式为1.M。 综上所述，IEEE754格式对应的浮点数真值可表示为： 真值与浮点数之间的转换IEEE754单精度浮点数与对应真值之间的转换流程： 真值转化为浮点数 浮点数转化为真值 为何阶码的偏移值为127而不是128首先要明白IEEE754标准中规定的特殊值： 所以,在规格化表示中8位移码理论上可以表示的表示范围为0~ 255,但是IEEE754中又规定,当阶码为00000000,尾数也为0的时候表示真值为0,结合S符号位,有正0和负0之分;而当阶码为11111111,尾数为0时,表示真值为无穷大,结合S符号位,有正无穷大和负无穷大,但是为了在规格化的浮点数中规避掉这种情况,所以将偏移值选择127,而不选128;这样阶码就变成1~ 254,对应的指数值就为-126~127;这也就解释了为什么偏移值要选择127,而不选择128的原因了。 感谢 《计算机组成原理》，秦磊华，吴非，莫正坤，清华大学出版社 计算机组成原理:IEEE754标准中,为什么指数真值e变成阶码加上的偏移值是127不是128?","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"http://yoursite.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"name":"IEEE754","slug":"IEEE754","permalink":"http://yoursite.com/tags/IEEE754/"}]},{"title":"Python列表的引用与赋值","slug":"Python列表的引用与赋值","date":"2020-02-24T13:24:30.000Z","updated":"2020-02-24T14:51:00.636Z","comments":true,"path":"2020/02/24/Python列表的引用与赋值/","link":"","permalink":"http://yoursite.com/2020/02/24/Python%E5%88%97%E8%A1%A8%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E8%B5%8B%E5%80%BC/","excerpt":"大家应该都做过这样的一个操作：a=[1,2,3] b=a，就是简单的对b“赋值”。这里面其实另有玄机……","text":"大家应该都做过这样的一个操作：a=[1,2,3] b=a，就是简单的对b“赋值”。这里面其实另有玄机…… 先看看下面的这些操作： 我们注意到一个问题：b = a操作实际上不是把a的内容复制一份给b，而是a和b指向同一个列表；而且进行操作a = [4,5,6]后，a就不和b指向同一列表了。 对于这些问题，我个人这样理解：首先python是一种面向对象的编程语言，代码之间皆为对象。那么操作a = [1,2,3]，就是a是一个对象的引用，这个对象是一个列表，列表的内容是1,2,3，而操作b = a实际上就是把a引用赋值给b，那么b也就自然而然的也是一个引用，而且与a是地址一样的引用。所以通过索引修改值时a和b都会更新。而对于a = [4,5,6]操作，[4,5,6]就是一个新的对象，且引用名为a。那么实际上就是修改了a的指向，但是并没有对b的指向进行操作，所以b还是原来列表对象的引用，而a则是新的列表的引用。 那么当我们不希望通过=操作后它们指向同一个列表，则可以进行如下操作: 123a = [1,2,3]b = a[:]print(a,b) 通过列表切片方式，就像是函数操作一样，返回值是一个列表，这个列表赋值给了变量b。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"小知识点","slug":"小知识点","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python列表保序去重","slug":"Python列表保序去重","date":"2020-02-24T13:24:06.000Z","updated":"2020-02-26T09:41:16.061Z","comments":true,"path":"2020/02/24/Python列表保序去重/","link":"","permalink":"http://yoursite.com/2020/02/24/Python%E5%88%97%E8%A1%A8%E4%BF%9D%E5%BA%8F%E5%8E%BB%E9%87%8D/","excerpt":"相信大家应该都有过对Python列表做过去重的操作，那么很多人应该都有过这样去重的操作：list(set(a))。但是由于经过set操作后生成的集合虽然无重复，但是是无序的。那么当我们需要在去重的同时又要保证列表顺序保持不变该怎样处理呢？","text":"相信大家应该都有过对Python列表做过去重的操作，那么很多人应该都有过这样去重的操作：list(set(a))。但是由于经过set操作后生成的集合虽然无重复，但是是无序的。那么当我们需要在去重的同时又要保证列表顺序保持不变该怎样处理呢？ 原始方法最开始我保序去重的操作是这样的： 123456alist = [1,1,2,3,2,4,4,5]blist = []for i in alist: if i not in blist: blist.append(i)print(b) 我相信很多人的操作也是类似的。哈哈哈！！！那么看完这篇文章就不要再那么粗鲁了。 进阶方法1234alist = [5,5,4,2,3,3,1]blist = list(set(alist))blist.sort(key=alist.index) # 按照alist列表的索引进行排序print(blist) 虽然上述方法比较简单，但是同时也必须需要开辟新的列表blist，占用空间。可以做一下小改进： 12345alist = [5,5,4,2,3,3,1]ind = alist.index # 提前获取去重前的indexalist = list(set(alist))alist.sort(key=ind)print(alist)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"小知识点","slug":"小知识点","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"__name__=='__main__'是个什么鬼","slug":"name-main-是个什么鬼","date":"2020-02-24T04:12:33.000Z","updated":"2020-02-24T04:35:08.378Z","comments":true,"path":"2020/02/24/name-main-是个什么鬼/","link":"","permalink":"http://yoursite.com/2020/02/24/name-main-%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC/","excerpt":"相信很多人在读别人的代码的时候都遇到过__name__==&#39;__main__&#39;这样一条语句。那么这一条语句到底有什么含义呢？今天我就要一探究竟。","text":"相信很多人在读别人的代码的时候都遇到过__name__==&#39;__main__&#39;这样一条语句。那么这一条语句到底有什么含义呢？今天我就要一探究竟。 同一目录下新建两个py文件 a.pyb.py 分别写入以下内容 123456789# a.py文件a = \"a\"print(a)print(a)# b.py文件import ab = \"b\"print(b) 运行b.py文件 结果为： 123aab 说明在import a时a.py文件被执行了一遍。那么很多时候我们只需要的时a中的某些函数，所以并不希望引入时产生不必要的输出。 修改a文件如下 12345a = \"a\"print(\"第一个\"+a)if __name__=='__main__': print(\"第二个\"+a) 执行a.py和b.py a.py结果为： 12第一个a第二个a b.py结果为： 12第一个ab 可以看出，在b中执行import a时a文件内容只被执行了两行。 总结出name==’main‘在代码中的作用是：保证脚本在以模块导入时不会自动执行__name__==&#39;__main__&#39;内的语句。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"小知识点","slug":"小知识点","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"seaborn调色板","slug":"seaborn调色板","date":"2020-02-01T13:54:30.000Z","updated":"2020-02-26T13:01:59.479Z","comments":true,"path":"2020/02/01/seaborn调色板/","link":"","permalink":"http://yoursite.com/2020/02/01/seaborn%E8%B0%83%E8%89%B2%E6%9D%BF/","excerpt":"","text":"在使用seaborn对数据进行可视化时，使用适当的颜色可以使做出的图表美观清晰。但是当需要的颜色较多时，我们就要依赖于seaborn的调色板工具了。 123456import warningswarnings.filterwarnings('ignore')import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sns seaborn的五种主题感谢：seaborn主题风格与调色板设定 12sns.set_style(\"darkgrid\") # 灰色网格sns.distplot(dt['petal_len'],bins=10) 12sns.set_style(\"whitegrid\") # 白色网格sns.distplot(dt['petal_len'],bins=10) 12sns.set_style(\"dark\") # 灰色sns.distplot(dt['petal_len'],bins=10) 12sns.set_style(\"white\") # 白色sns.distplot(dt['petal_len'],bins=10) 12sns.set_style(\"ticks\") # 没看出它与white的区别sns.distplot(dt['petal_len'],bins=10) color_palette调色板默认主题有六种变化：deep, muted, pastel, bright, dark, colorblind.感谢：Choosing color palettes 在导入seaborn时，默认的颜色循环被更改为一组10种颜色，这组颜色唤起了标准的matplotlib颜色循环，目的是为了看起来更美观。 1sns.set() 123# 默认颜色 10种current_palette = sns.color_palette()sns.palplot(current_palette) 圆形颜色系统当你要区分任意数量的类别而不强调任何一个时，最简单的方法是在圆形颜色空间中画均匀间隔的颜色。最常用的方法是使用hls颜色空间，这是对RGB值的简单转换。 1sns.palplot(sns.color_palette(\"hls\",n_colors=8)) 也可以使用hls_palette()函数控制亮度和饱和度 1sns.palplot(sns.hls_palette(n_colors=8,l=0.5,s=0.8)) # l=亮度 s=饱和度 由于人类视觉系统的工作方式，在RGB水平上即使是强烈的颜色看起来也不一定那么强烈。我们认为黄色和绿色是相对较亮的颜色，蓝色是相对较暗的颜色，这在试图与hls系统保持一致时可能是一个问题。为了弥补这一点，seaborn提供了一个husl系统的接口(后来改名为HSLuv)，这也使它很容易选择均匀间隔的色调，同时保持明显的亮度和饱和度更加均匀。 12sns.palplot(sns.color_palette(\"husl\", 8))# 虽然不明白上面一段话的意思，但是husl看起来比hls更加均匀 同样有husl_palette()函数可以设置亮度饱和度 分类的Color Brewer调色板1sns.palplot(sns.color_palette(\"Paired\")) # paire成对的，颜色成对出现 1sns.palplot(sns.color_palette(\"Set2\")) # 颜色差别比较大 choose_colorbrewer_palette()函数可以调用Color Brewer工具，只能在Jupyter Notebook上使用 12a = sns.choose_colorbrewer_palette(data_type='diverging') # 必须参数# sequential 连续的, diverging 分散的, qualitative 定性的 1sns.palplot(a) 调用该工具后，可以自己调整参数得到自己满意的颜色空间。例如上面的例子，在调整的过程中，a的值是实时变化的。所以调整之后可以直接使用，不用再次运行 连续调色板参数就是主题颜色的名字，名字后面加s即可。如果想颜色顺序反转，在名字后面加_r即可。颜色加深则最后加_d。 123sns.palplot(sns.color_palette(\"Blues\"))sns.palplot(sns.color_palette(\"Blues_r\"))sns.palplot(sns.color_palette(\"Blues_d\")) 123sns.palplot(sns.color_palette(\"Purples\"))sns.palplot(sns.color_palette(\"Purples_r\"))sns.palplot(sns.color_palette(\"Purples_d\")) 自定义连续调色板对于自定义顺序调色板的更简单的接口，您可以使用light_palette()或dark_palette()，它们都使用单一颜色，并生成一个调色板，从浅色或深色去饱和值过渡到该颜色。这些函数还伴随着choose_light_palette()和choose_dark_palette()函数，它们启动交互式小部件来创建这些调色板。 1sns.palplot(sns.light_palette(\"green\",n_colors=10)) 1sns.palplot(sns.dark_palette(\"red\",reverse=True,n_colors=10)) 1col_pal = sns.choose_light_palette() 1sns.palplot(col_pal) 具体参数请参考：choose_light_palette、choose_dark_palette 离散调色板1sns.palplot(sns.color_palette(\"BrBG\", 10)) # brown-green 1sns.palplot(sns.color_palette(\"RdBu_r\", 10)) # red-blue 1sns.palplot(sns.color_palette(\"coolwarm\", 10)) # 冷色调-暖色调 自定义颜色列表如果我们有自己喜欢的颜色，可以自己定义一个颜色列表。 12flatui = [\"#FFC0CB\", \"#8A2BE2\", \"#0000FF\", \"#00BFFF\", \"#FF8C00\", \"#40E0D0\"]sns.palplot(sns.color_palette(flatui)) 应用实例12345678910plt.figure(figsize=(12,8))flatui = sns.color_palette([\"#FFC0CB\", \"#8A2BE2\", \"#FF8C00\", \"#00BFFF\"]) # 颜色种类不足时循环使用palettes = ['husl','coolwarm','Purples_r',flatui]pal_names = ['husl','coolwarm','Purples_r','custom']sns.set_style(\"darkgrid\")for i,pal in enumerate(palettes): plt.subplot(2,2,i+1) sns.boxplot(data=dt,palette=pal,orient=\"h\") plt.title(pal_names[i])plt.show()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"seaborn","slug":"seaborn","permalink":"http://yoursite.com/tags/seaborn/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"机器学习——决策树算法","slug":"机器学习——决策树算法","date":"2020-01-27T07:54:45.000Z","updated":"2020-02-12T03:00:42.034Z","comments":true,"path":"2020/01/27/机器学习——决策树算法/","link":"","permalink":"http://yoursite.com/2020/01/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"决策树是一个类似流程图的树形结构，决策树分类方法以树的形式采用自上而下的方式给出分类规则。其优点在于：1.决策树是一个类似流程图的树形结构，决策树分类方法以树的形式采用自上而下的方式给出分类规则；2.决策树算法的运算速度要快于其他分类方法；3.决策树分类方法得到的结果的准确率要优于其他算法。","text":"决策树是一个类似流程图的树形结构，决策树分类方法以树的形式采用自上而下的方式给出分类规则。其优点在于：1.决策树是一个类似流程图的树形结构，决策树分类方法以树的形式采用自上而下的方式给出分类规则；2.决策树算法的运算速度要快于其他分类方法；3.决策树分类方法得到的结果的准确率要优于其他算法。 测试数据 信息熵记得高中化学书上有关于熵(entropy)的介绍，当时老师说是用来描述事物的混乱程度的。百度百科上的熵的定义。信息是个很抽象的概念。人们常常说信息很多，或者信息较少，但却很难说清楚信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到1948年，香农提出了“信息熵(information entropy)”的概念，才解决了对信息的量化度量问题。信息熵这个词是C．E．香农从热力学中借用过来的。热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。 例如：小明和小华下棋，两人势均力敌，每个人胜利的概率都是1/2，则每局的结果的熵值： 1H(X) = -(0.5\\*log0.5 + 0.5\\*log0.5) = 1bit 也就是说我们使用1bit大小的空间就能表示结果的所有情况。同理可得测试数据中的play的信息熵是H(play) = 0.940285959bit 条件熵我的理解就是：在变量Y确定的情况下，变量X的信息熵。例如测试数据中在temperature变量确定的情况下，计算play的条件熵： temperature 概率 yes no hot 4/14 2 2 mild 6/14 4 2 cool 4/14 3 1 计算： 1234H(X|temp) = (4/14)*(-2/4*log2/4-2/4*log2/4)+ (6/14)*(-4/6*log4/6-2/6*log2/6)+ (4/14)*(-3/4*log3/4-1/4*log1/4) = 0.911063393bit 信息增益虽然可以采用任何一个特征对数据集进行划分，但最后形成的决策树会差异很大。需要寻找合适的特征，其中就需要信息增益作为参考。称为ID3算法。 信息增益 = 信息熵 - 条加熵 例如测试数据中第一轮temperature特征的信息增益为：gain(temp) = H(play) - H(play|yemp) = 0.029同理得到： gain(outlook) = 0.247gain(humidity) = 0.152gain(windy) = 0.048 在选择分支属性时，选择信息增益最大的特征outlook，此时信息熵减少的越多。这样可以使得经过该特征分类之后，数据的信息熵最小，也就是说数据的“纯度”(确定度)越高。 构建决策树流程图： 由上图可知，决策树构建过程是一个递归的规程，每一轮构建方式相同。当“当前节点的所有样本都为同一种类型”时则结束构建。第一轮构建： 信息增益率ID3算法具有以下缺点： 对于各类别样本数量不一致的数据, 信息增益偏向于那些更多数值的特征 容易过拟合 忽略属性之间的相关性 当样本中某个特征的属性很多，且每个属性对应的分类又十分的少时，就会出现信息增益非常大，过拟合现象。 例如当某个样本中的一个特征具有n个属性，每个属性对应一个分类，就会出现全部-1/n*1*log1的情况，此时的条件熵为0，信息增益最大化。为了减少这种现象，引入了信息增益率(C4.5算法)。 1信息增益率 = 条件熵 / 自身的信息熵 上述例子中，该特征的自身信息熵为-n*(1/n)*log(1/n) = logn，当n比较大时，自身信息熵就会非常大，信息增益率就会降低。 代码实战Github代码地址如果Github加载超时，点击这个地址鸢尾花数据集 感谢 【结合实例】信息增益的计算 通俗理解条件熵 信息增益到底怎么理解呢？ 决策树基本概念及算法优缺点","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"决策树","slug":"决策树","permalink":"http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"分类算法","slug":"分类算法","permalink":"http://yoursite.com/tags/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"}]},{"title":"MySQL——增删改查","slug":"MySQL——增删改查","date":"2020-01-26T12:20:36.000Z","updated":"2020-02-12T03:16:05.843Z","comments":true,"path":"2020/01/26/MySQL——增删改查/","link":"","permalink":"http://yoursite.com/2020/01/26/MySQL%E2%80%94%E2%80%94%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"MySQL的四个基本操作——增删查改，最近两天学习了一些SQL的语法，对这四种进行总结，内容都是最最最基础最最简单的一些操作。","text":"MySQL的四个基本操作——增删查改，最近两天学习了一些SQL的语法，对这四种进行总结，内容都是最最最基础最最简单的一些操作。 预备知识 新建数据库create database DB_name;，同时在data文件夹下创建一个名为test的文件夹。 显示数据库show databases;，注意databases是复数。 删除数据库drop database DB_name; 使用数据库use DB_name; 新建数据表12345create table stu( id int primary key, name varchar(20), GPA float); primary key修饰主键（不得重复且不得为空），int varchar float等是数据类型。 显示数据库中所有数据表show tables; 删除数据表drop table TAB_name; 查询数据表中的字段describe TAB_name;或者desc TAB_name; 增关键字：insert 添加完整记录insert into stu values(1,&#39;xm&#39;,3.122); 添加指定字段的记录insert into stu (id,name) values(2,&#39;lh&#39;); 查关键字：select 查询所有记录select * from stu; where条件查找select * from stu where id=1;select * from stu where id&lt;2; 指定显示某些字段select id,name from stu; in和not in的使用select * from stu where id in(1,2,3);，查询id是1/2/3的全部记录；select * from stu where id not in(2,3);，查询所有id不是2/3的记录。 更多 改关键字：updateupdate stu set id=3,name=&#39;xxm&#39; where id=1; update是对表记录进行修改，对表进行字段修改使用alter。 删关键字：deletedelete from stu where id=2; 感谢 PHP MySQL Update MySQL 查询语句篇 MySQL DELETE 语句 Mysql—-修改语句（alter）","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Anaconda创建虚拟环境并使用Jupyter notebook选择虚拟环境","slug":"Anaconda创建虚拟环境并使用Jupyter-notebook打开虚拟环境","date":"2020-01-18T11:08:40.000Z","updated":"2020-02-12T03:16:07.944Z","comments":true,"path":"2020/01/18/Anaconda创建虚拟环境并使用Jupyter-notebook打开虚拟环境/","link":"","permalink":"http://yoursite.com/2020/01/18/Anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%BD%BF%E7%94%A8Jupyter-notebook%E6%89%93%E5%BC%80%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"由于需要使用Tensorflow的1.xx的低版本，但是cmd下载一直报错没有解决，就想着用Anaconda，但是真实环境我已经装上Tensorflow2.0了不想换了，所以就想着再建一个python3.6的虚拟环境。不过这个过程还是比较曲折的，这篇文章把整个过程的操作和报错解决方法记录下来，以备后用。内容包括虚拟环境建立、添加虚拟环境到jupyter notebook以及错误解决方法","text":"由于需要使用Tensorflow的1.xx的低版本，但是cmd下载一直报错没有解决，就想着用Anaconda，但是真实环境我已经装上Tensorflow2.0了不想换了，所以就想着再建一个python3.6的虚拟环境。不过这个过程还是比较曲折的，这篇文章把整个过程的操作和报错解决方法记录下来，以备后用。内容包括虚拟环境建立、添加虚拟环境到jupyter notebook以及错误解决方法 建立Anaconda虚拟环境 以管理员身份运行Anaconda Prompt 输入以下命令：conda create --name your_env_name python=x.xyour_env_name 是你的虚拟环境的名称，x.x是 虚拟环境的python的版本，根据需求来定。这一步我遇到了[WinError 127] 找不到系统文件的错误。解决方式见第三节。 激活虚拟环境windows: activate py3envLinux: source activate py3env激活后就是进入了新建的虚拟环境，如下图： 虚拟环境建立完成，可以安装各种包了。 附： 退出虚拟环境：deactivate 查找虚拟环境：conda info -e 或者 conda info --envs带有“*”的是默认真实环境。 删除：conda remove -n your_env_name --all Jupyter notebook选择环境 安装ipykernel：conda install ipykernel如果不可行就使用pip install ipykernel不要问为什么，反正用conda时提示有些东西没装，换成pip瞬间成功。（能用就行） 激活虚拟环境 将环境写入Notebook的kernel中：python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot; 打开Jupyter notebook，新建Python文件 [WinError 127] 找不到指定的程序现象： 原因：Anaconda/DLLS/libssl-1_1-x64.dll 和 Anaconda/Library/bin/libssl-1_1-x64.dll中的日期不一致。解决：将Anaconda/DLLS/libssl-1_1-x64.dll替换掉Anaconda/Library/bin/libssl-1_1-x64.dll（直接复制替换）效果： 感谢 Anaconda 配置虚拟环境 jupyter notebook选择conda环境 anaconda winerror 127找不到指定的程序","categories":[{"name":"实用工具/操作","slug":"实用工具-操作","permalink":"http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://yoursite.com/tags/Anaconda/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Jupyter notebook","slug":"Jupyter-notebook","permalink":"http://yoursite.com/tags/Jupyter-notebook/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"}]},{"title":"Java进阶-类","slug":"Java进阶-类","date":"2020-01-16T13:31:59.000Z","updated":"2020-01-16T14:16:10.825Z","comments":true,"path":"2020/01/16/Java进阶-类/","link":"","permalink":"http://yoursite.com/2020/01/16/Java%E8%BF%9B%E9%98%B6-%E7%B1%BB/","excerpt":"今天对Java进行了初步的深入理解，收获不少。在入门之前我看Java留下的第一印象就是“代码都是在一个类中编写实现的”。所以我觉得想学Java就要首先学习类的知识，对于类这个知识点，不同语言的大致思想一样，所以在学习C++和Python的类之后Java学习来就不会那么痛苦了。","text":"今天对Java进行了初步的深入理解，收获不少。在入门之前我看Java留下的第一印象就是“代码都是在一个类中编写实现的”。所以我觉得想学Java就要首先学习类的知识，对于类这个知识点，不同语言的大致思想一样，所以在学习C++和Python的类之后Java学习来就不会那么痛苦了。 基本知识当编写一个Java源代码文件时，此文件通常被称为编译单元。每个编译单元都必须有一个后缀名.java，而在编译单元内有且仅有一个public类，否则编译器就不会接受。该public类的名称必须与文件的名称相同（包括大小写，但不包括后缀名.java）。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，因为它们不是public类，而且它们主要用来为主public类提供支持。 当编译一个.java文件（即一个编译单元）时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与.java文件中每个类的名称相同，只是多了一个后缀名.class。因此在编译少量.java文件之后，会得到大量的.class文件。每一个.java文件编译以后都会有一个public类，以及任意数量的非public类。因此每个.java文件都是一个构件，如果希望许许多多的这样的构件从属于同一个群组，就可以在每一个.java文件中使用关键字package。而这个群组就是一个类库。 实例分析实例代码由三个.java文件(Example.java,People.java,Address.java)组成，同属于一个包。每一个.java文件内只有一个public class。 对每一个语句的解读分析都在注释里面。 Address.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package JavaAdvanced;// 定义类/类的封装public class Address &#123; // private 定义私有实例变量 // 外部程序不能直接访问和修改私有实例变量 private String province; private String city; // 构造函数/构造器 // 不是没有返回值，而是返回值是其本身，无需赘述 // Java不支持默认参数，与C++不同 // 可以通过重载实现与默认参数相同效果 public Address(String province, String city) &#123; this.city = city; this.province = province; &#125; public Address() &#123; // 重载 province = \"安徽\"; city = \"界首\"; &#125; // 实例方法 // 没有加static声明的方法称为实例方法 // 带有static的方法：public static void main(String[] args) // 实例方法在使用时必须要有对象/实例 // 调用方法为：对象名.方法名(实参列表) public void setProv(String provice) &#123; this.province = provice; &#125; public void setCity(String chengshi) &#123; city = chengshi; &#125; // this关键字 // 每一个对象都有的属性，一个引用 // 在JVM中，this指向自己属于的那个类 // 在setProv方法中this.province就是指该类中的实例变量province // 而没使用this的province就是指形参中的province // 如果setProv的内容写成：province = province; // 不会error/warning，但是两个province都指形参（就近原则） // setCity中的city之所以没使用this是因为变量不会混淆 // city只能是当前对象的实例变量 public String getProv() &#123; return province; &#125; public String getCity() &#123; return city; &#125;&#125; People.java123456789101112131415161718192021222324252627282930package JavaAdvanced;// 定义类public class People &#123; String name; // 名字 int age; // 年龄 Address addr; // 声明一个对象，不占内存 public People(String name,int age,String province,String city) &#123; this.name = name; this.age = age; // 实例化addr对象，调用无参构造方法 // 若不进行初始化则会error，因为jvm中没有为addr分配内存 addr = new Address(); //调用午餐构造函数 System.out.println(\"调用无参构造函数实例化对象addr\"); System.out.println(\"province=\"+addr.getProv()); System.out.println(\"city=\"+addr.getCity()+'\\n'); // 调用Address类的实例方法 this.addr.setProv(province); this.addr.setCity(city); &#125; public void Self_Introduction() &#123; System.out.format(\"My name is %s.\\n\",name); System.out.format(\"I'm %d years old.\\n\",age); System.out.format(\"我来自%s省%s市。\\n\\n\",addr.getProv(),addr.getCity()); &#125;&#125; Example.java12345678910111213141516171819202122232425262728package JavaAdvanced;public class Example &#123; // 带有static的方法 // 不能使用this关键字 // 是被类调用的方法，而非对象 // 调用方法：类名.方法名(形参); or 方法名(形参); // 可在main前或者后定义，例如sum2() public static int sum1(int a,int b) &#123; return a+b; &#125; public static void main(String[] args) &#123; // 实例化mqg这一对象并调用构造方法初始化 People mqg = new People(\"QingguoMeng\",20,\"河南\",\"焦作\"); mqg.Self_Introduction(); // 调用带有static的方法 System.out.println(Example.sum1(1, 2)); // 带类名 System.out.println(sum2(3, 4)); // 不带类名 &#125; public static int sum2(int a,int b) &#123; return a+b; &#125;&#125; 运行结果运行Example.java文件结果为： 12345678910调用无参构造函数实例化对象addrprovince=安徽city=界首My name is QingguoMeng.I&apos;m 20 years old.我来自河南省焦作市。37 感谢 Java零基础教程视频（适合Java 0基础，Java初学入门） Java类的定义及其实例化 为什么java函数不支持参数默认值? 深入理解java中的package关键字","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/%E7%B1%BB/"},{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"}]},{"title":"Java入门第二天","slug":"Java入门第二天","date":"2020-01-15T08:10:31.000Z","updated":"2020-01-15T11:23:58.086Z","comments":true,"path":"2020/01/15/Java入门第二天/","link":"","permalink":"http://yoursite.com/2020/01/15/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"今天是入门Java的第二天，也是最后一天，今天入门学习函数一个知识点。","text":"今天是入门Java的第二天，也是最后一天，今天入门学习函数一个知识点。 函数Java递归实现斐波那契数列代码： 1234567891011121314151617181920212223package second_java;import java.util.Scanner;public class HanShu &#123; // 递归实现斐波那契数列 public static int sum(int a) &#123; // 自定义函数 if(a==1 || a==2) return 1; else return sum(a-1) + sum(a-2); &#125; public static void main(String[] args) &#123; // 主函数 // TODO Auto-generated method stub int x; Scanner in = new Scanner(System.in); x = in.nextInt(); System.out.println(sum(x)); in.close(); &#125;&#125; 运行结果： 总结Java中函数定义中public static目前不理解具体意思，需要强行记忆。Java定义的函数，调用时也是遵循值传递的规则。除去定义区别，基本与C/C++无差。 感谢 B站浙江大学翁恺老师的Java入门课程","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"Java入门第一天","slug":"Java入门第一天","date":"2020-01-14T13:15:17.000Z","updated":"2020-01-15T10:58:51.640Z","comments":true,"path":"2020/01/14/Java入门第一天/","link":"","permalink":"http://yoursite.com/2020/01/14/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"2020年的寒假，开始入门Java。在2019年学习了C/C++、Python之后，今年学习Java起来感觉轻松很多，都说编程语言一通百通。经过一天的学习收获也不少。","text":"2020年的寒假，开始入门Java。在2019年学习了C/C++、Python之后，今年学习Java起来感觉轻松很多，都说编程语言一通百通。经过一天的学习收获也不少。 基本语法Java中的基本语法除IO操作外同C/C++中几乎相同。 Java中输出使用: System.out.println() 输出内容并自动在结尾输出回车。 System.out.print() 末尾不输出回车 System.out.printf() 同C中的printf使用几乎一样，可以对输出做格式控制 System.out.format() 同上 Java中输入时首先创建一个Scanner类，同时需要import java.util.Scanner,最后需要关闭这个类，不关闭会出现警告但不会error。对于数值型变量可使用in.nextInt(),in.nextFloat()等方式读取对应类型的数值。 车票售票机代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package hello;import java.util.Scanner;public class Hello &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scan = new Scanner(System.in); //建立一个输入流对象scan final int yuanjia = 10; //final定义静态变量 int price = 0; int p; int n,m; char flag = 'Y'; while(flag == 'Y') &#123; System.out.print(\"请投币:\"); p = scan.nextInt(); // 输入一个整数 price = p + price; System.out.printf(\"您需要几张票？\"); m = n = scan.nextInt(); // n被输入赋值，m被n赋值，m与n内存地址不同// m = n; if(price&gt;=yuanjia*n) &#123;// int i; for(int i=n;i&gt;0;i-=1) &#123; System.out.println(\"***********************\"); System.out.println(\"* 欢迎乘坐JAVA2020次列车 *\"); System.out.println(\"* 票价：\"+yuanjia+\" *\"); //println()使用+进行格式控制输出 System.out.println(\"***********************\\n\"); &#125; System.out.println(\"余额：\"+(price-yuanjia*m)); System.out.print(\"继续购票？[Y/N]\"); flag = scan.next().charAt(0); if(flag == 'N') &#123; System.out.format(\"找零：%d\\n\",price-yuanjia*m); //format进行格式化输出 &#125; else &#123; price -= yuanjia*m; // 允许组合赋值 &#125; &#125; else &#123; System.out.printf(\"余额不足，剩余%d，是否继续买票？[Y/N]\",price); //printf()可使用%d、%f等格式化输出 flag = scan.next().charAt(0); // 输入一个字符 if(flag == 'N') &#123; System.out.println(\"找零\"+(price)); &#125; &#125; System.out.println(); // 输出一个换行 &#125; System.out.println(\"感谢乘坐JAVA列车，很荣幸为您服务，欢迎下次再来！\"); scan.close(); // 关闭输入流对象 &#125;&#125; 运行结果： 数组Java数组定义方式：int[] arr = new int[100],开头的int[]中括号内不能出现数字,也使用下标访问的方式。 1234567891011121314151617package F;public class Fib &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr = new int[21]; // 定义数组，开头的int[]中括号内不能出现数字 arr[1] = arr[2] = 1; for(int i=3;i&lt;=20;i++) &#123; arr[i] = arr[i-1] + arr[i-2]; &#125; for(int i=1;i&lt;=20;i++) &#123; System.out.printf(\"%d\\n\",arr[i]); &#125; &#125;&#125; Java中数组的长度在定义时可以是变量，且可以使用arr.length的方式求得数组arr的长度。 12345678910111213141516171819202122package FF;import java.util.Scanner;public class Fib2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] fib = new int[n+1]; // 数组长度可以是变量 fib[1] = fib[2] = 1; for(int i=3;i&lt;=n;i++) &#123; fib[i] = fib[i-1] + fib[i-2]; &#125; for(int i=1;i&lt;=n;i++) &#123; System.out.println(fib[i]); &#125; System.out.printf(\"fib的长度是%d\",fib.length); // arr.length可以获取数组的长度 in.close(); &#125;&#125; 注意：fib.length中的length没有中括号，不同于C++中求字符串的长度。 字符与字符串Java中的字符串输入可以使用in.nextLine(),读取一行内容，以回车为分隔；字符读取可以使用in.next().charAt(0); 12345678910111213141516171819202122package zifu;import java.util.Scanner;public class Char &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in); String s1,s2,s3; // 注意大写String首字母 s1 = in.nextLine(); // 读取一行的内容,以回车为结束符 s2 = in.next(); // 读取一行内容的第一个单词 以空格、回车、tab建分隔 System.out.print(s1+'\\n'+s2+'\\n'); s3 = \"This\"; System.out.println(s2 == s3); // 不能判断s2与s3的内容是否相等 System.out.println(s2.equals(s3)); // 判断s2与s3的内容是否相等 System.out.println(\"abc\".compareTo(\"abd\")); // 比较字符串大小 System.out.println(\"123456789\".substring(1,4)); // 切片，左闭右开 System.out.println(\"123456789\".substring(1,9)); // 要想取到最后一个字符，结束参数为字符串长度 in.close(); &#125;&#125; 运行结果： 字符串另一种定义并初始化的方法：String s = new String(&quot;mqg&quot;) 总结在学习Java时，可以体验到C/C++与Python的感觉，但是Java的特性也十分突出，特别是Java开头的语法内容还是不懂，他没有C/C++易于理解，暂且理解为固定格式。 感谢 B站浙江大学翁恺老师的Java入门课程 java输入单个字符的2种方法： Java的格式化输出","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基本语法","slug":"基本语法","permalink":"http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"HPUoj-假币问题","slug":"HPUoj-假币问题","date":"2019-12-21T15:03:47.000Z","updated":"2019-12-21T15:30:43.848Z","comments":true,"path":"2019/12/21/HPUoj-假币问题/","link":"","permalink":"http://yoursite.com/2019/12/21/HPUoj-%E5%81%87%E5%B8%81%E9%97%AE%E9%A2%98/","excerpt":"河南理工大学oj题库的假币问题。三分是这个题目的关键。","text":"河南理工大学oj题库的假币问题。三分是这个题目的关键。 思路：如果有三个硬币A，B，C：随便两个放在天平上（加入是A，B），如果A=B，则C是假币；如果A&lt;B，则说明小的A是假币。 再来看一下20个硬币的情况：如图所示，每次将硬币三分，题目问的是最少多少次一定能分出结果，所以每次三分之后选择最大的一份就可以了。每次最大数量是上次结果n/3并向上取整。当n=0或者n=1时结束三分。 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main(){ long long n; // n比较大，所以定义long long int while(1){ cin&gt;&gt;n; if(!n) break; long long res = 0; // 记录次数 // 循环出结果 while(1) { if(n&gt;=2) { n = ceil(double(n)/3.0); // n/3的结果向上取整 res++; } else break; } cout&lt;&lt;res&lt;&lt;endl; } } 感谢：https://www.cnblogs.com/Edviv/p/11588555.html","categories":[{"name":"oj","slug":"oj","permalink":"http://yoursite.com/categories/oj/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"HPU","slug":"HPU","permalink":"http://yoursite.com/tags/HPU/"},{"name":"假币问题","slug":"假币问题","permalink":"http://yoursite.com/tags/%E5%81%87%E5%B8%81%E9%97%AE%E9%A2%98/"}]},{"title":"HDU1716 排列2","slug":"HDU1716-排列2","date":"2019-12-16T13:30:58.000Z","updated":"2019-12-21T15:30:46.598Z","comments":true,"path":"2019/12/16/HDU1716-排列2/","link":"","permalink":"http://yoursite.com/2019/12/16/HDU1716-%E6%8E%92%E5%88%972/","excerpt":"问题来自于航电的oj题目。这道题目，我看网网上有很多比较高大上的解法，可是我没时间看了呀，我马上就考试了，还有四十多道题目没刷呢。在这种情况下，为了得高分，我只能用四层循环暴力求解了。","text":"问题来自于航电的oj题目。这道题目，我看网网上有很多比较高大上的解法，可是我没时间看了呀，我马上就考试了，还有四十多道题目没刷呢。在这种情况下，为了得高分，我只能用四层循环暴力求解了。 这道题目，可以看出来所给的四个数字都是升序的，所以可以不用再对数字排序，直接依次遍历就好了。 因为这一题数据量特别小，使用多层循环不会超时，但是还是建议多看点高效的解法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int main()&#123; int arr[4]; int ff = 1; // 控制输出格式 while(scanf(\"%d%d%d%d\",arr,arr+1,arr+2,arr+3))&#123; if(arr[0]==0&amp;&amp;arr[1]==0&amp;&amp;arr[2]==0&amp;&amp;arr[3]==0) break; if(ff) ff = 0; else cout&lt;&lt;endl; int re_arr[25]; // 存放结果 int res = 0, ind = 0; for(int i=0;i&lt;4;i++)&#123; if(arr[i]==0) continue; // 千位数不为0 int emp = 0; // 输出结果时是否先输出一个空格 int ent = 0; // 是否最后输出回车换行 for(int j=0;j&lt;4;j++)&#123; if(j==i) continue; // 不能重复，下同 for(int k=0;k&lt;4;k++)&#123; if(k==i || k==j) continue; for(int L=0;L&lt;4;L++)&#123; if(L==i || L==k || L==j) continue; res = 1000*arr[i]+100*arr[j]+10*arr[k]+arr[L]; int f = 0; for(int m=0;m&lt;ind;m++) if(res == re_arr[m])&#123; // res已存在，本次res不存储不输出 f = 1; break; &#125; if(!f)&#123; re_arr[ind++] = res; ent = 1; // 本次有结果输出，该行结尾输出回车换行 if(!emp)&#123; // 第一个数字，直接输出结果 cout&lt;&lt;res; emp = 1; &#125; else cout&lt;&lt;\" \"&lt;&lt;res; // 不是第一个数字，先输出空格再输出结果 &#125; &#125; &#125; &#125; if(ent) // 有输出，所以输出回车换行 cout&lt;&lt;endl; &#125; &#125;&#125; 这个思路其实非常简单，但是航电oj最恶心人的是死磕输出格式，空格、回车等一个不能多一个不能少。该题就是一个典型例子，这题浪费我时间最多的不是思路，而是输出格式。 感谢他的代码，给了我输出格式方面的提示。","categories":[{"name":"oj","slug":"oj","permalink":"http://yoursite.com/categories/oj/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"HDU","slug":"HDU","permalink":"http://yoursite.com/tags/HDU/"},{"name":"排列","slug":"排列","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%88%97/"},{"name":"暴力求解","slug":"暴力求解","permalink":"http://yoursite.com/tags/%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/"}]},{"title":"HDU1233 还是通畅工程","slug":"HDU1233-还是通畅工程","date":"2019-12-16T11:45:50.000Z","updated":"2019-12-21T15:30:48.938Z","comments":true,"path":"2019/12/16/HDU1233-还是通畅工程/","link":"","permalink":"http://yoursite.com/2019/12/16/HDU1233-%E8%BF%98%E6%98%AF%E9%80%9A%E7%95%85%E5%B7%A5%E7%A8%8B/","excerpt":"问题来自于航电的oj题目。这个题目就是最小生成树的应用，我使用克鲁斯卡尔算法解题。","text":"问题来自于航电的oj题目。这个题目就是最小生成树的应用，我使用克鲁斯卡尔算法解题。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;struct INF&#123; int head,tail; // 边的始终点 long w; // 权重 &#125;Road[6000];bool cmp(struct INF inf_1,struct INF inf_2)&#123; // 结构体按照某一关键字排序 return inf_1.w &lt; inf_2.w; // 升序 以权重为关键字 &#125;int main()&#123; int N; while(cin&gt;&gt;N)&#123; if(!N) break; int vil[105]; // 村庄 for(int i=1;i&lt;=N;i++) vil[i] = i; //初始时各自形成一个联通路 // 建立Road信息表 for(int i=1;i&lt;=N*(N-1)/2;i++) cin&gt;&gt;Road[i].head&gt;&gt;Road[i].tail&gt;&gt;Road[i].w; sort(Road+1,Road+1+N*(N-1)/2,cmp); //按照权值从小到大排序 // for(int i=1;i&lt;=N*(N-1)/2;i++) cout&lt;&lt;Road[i].w&lt;&lt;'\\t'; cout&lt;&lt;endl; // 显示权重排序结果 long sum_w = 0; int H,T; for(int i=1;i&lt;=N*(N-1)/2;i++) if(vil[Road[i].head] != vil[Road[i].tail])&#123; // 该条路的始终点不在同一连通区域 sum_w += Road[i].w; // 加入该条路 // 合并两个连通区域成一个整体 H = vil[Road[i].head]; T = vil[Road[i].tail]; for(int j=1;j&lt;=N;j++) //合并 if(vil[j] == H) vil[j] = T; &#125; cout&lt;&lt;sum_w&lt;&lt;endl; &#125;&#125; 重点记忆sort(Road+1,Road+1+N*(N-1)/2,cmp);中的Road+1+N*(N-1)/2，而非Road+N*(N-1)/2。 感谢：https://blog.csdn.net/lichunchi123/article/details/79630260","categories":[{"name":"oj","slug":"oj","permalink":"http://yoursite.com/categories/oj/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"HDU","slug":"HDU","permalink":"http://yoursite.com/tags/HDU/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"通畅工程","slug":"通畅工程","permalink":"http://yoursite.com/tags/%E9%80%9A%E7%95%85%E5%B7%A5%E7%A8%8B/"}]},{"title":"C++中用sort()给数组排序","slug":"C-中的sort-排序函数","date":"2019-12-08T14:16:24.000Z","updated":"2019-12-08T14:34:22.607Z","comments":true,"path":"2019/12/08/C-中的sort-排序函数/","link":"","permalink":"http://yoursite.com/2019/12/08/C-%E4%B8%AD%E7%9A%84sort-%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/","excerpt":"科普中国：sort函数用于C++中，对给定区间所有元素进行排序，默认为升序，也可进行降序排序。sort函数进行排序的时间复杂度为nlog2n，比冒泡之类的排序算法效率要高，sort函数包含在头文件为#include&lt;algorithm&gt;的C++标准库中。","text":"科普中国：sort函数用于C++中，对给定区间所有元素进行排序，默认为升序，也可进行降序排序。sort函数进行排序的时间复杂度为nlog2n，比冒泡之类的排序算法效率要高，sort函数包含在头文件为#include&lt;algorithm&gt;的C++标准库中。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt; // 使用sort函数需要包含的头文件 #define N 5 //数组的长度 using namespace std; bool cmp(int a,int b)&#123; return a&gt;b; //表示降序，a&lt;b表示升序 &#125;int main()&#123; int arr1[N] = &#123;2,3,1,4,2&#125;; int arr2[N] = &#123;2,3,1,4,2&#125;; int arr3[N] = &#123;2,3,1,4,2&#125;; sort(arr1,arr1+N); //前两个参数是待排序数据的地址范围 默认升序 sort(arr2,arr2+N,cmp); //若想降序则需要自定义cmp函数 sort(arr3+1,arr3+4); //局部排序 cout&lt;&lt;\"升序arr1:\\t\"; for(int i=0;i&lt;N;i++) cout&lt;&lt;arr1[i]&lt;&lt;\"\\t\"; cout&lt;&lt;endl; cout&lt;&lt;\"降序arr2:\\t\"; for(int i=0;i&lt;N;i++) cout&lt;&lt;arr2[i]&lt;&lt;\"\\t\"; cout&lt;&lt;endl; cout&lt;&lt;\"局部arr3:\\t\"; for(int i=0;i&lt;N;i++) cout&lt;&lt;arr3[i]&lt;&lt;\"\\t\"; cout&lt;&lt;endl;&#125;/*运行结果：升序arr1: 1 2 2 3 4降序arr2: 4 3 2 2 1局部arr3: 2 1 3 4 2*/","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"小知识点","slug":"小知识点","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"C++类与对象","slug":"C++类与对象","date":"2019-11-29T14:19:46.000Z","updated":"2019-12-08T14:31:17.225Z","comments":true,"path":"2019/11/29/C++类与对象/","link":"","permalink":"http://yoursite.com/2019/11/29/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"说明：该篇文章是本人学习C++的学习记录，内容都是本人的独自理解。所以，内容难免会存在不严谨或理解上的偏差等现象，欢迎留言探讨。","text":"说明：该篇文章是本人学习C++的学习记录，内容都是本人的独自理解。所以，内容难免会存在不严谨或理解上的偏差等现象，欢迎留言探讨。 学习资料： 1.《C++面向对象程序设计教程(第三版)》 作者：陈维兴 林小茶 清华大学出版社 2.《C++语言程序设计(第四版)》 作者：郑莉 董渊 何江舟 清华大学出版社 面向对象程序设计的基本特点抽象抽象是指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以标书的过程。抽象包括两个方面：数据抽象、行为抽象 举例：对人进行抽象。 数据抽象：姓名(string name)、性别(string sex)、年龄(int age)等。行为抽象：行走 [ walk() ]、吃饭 [ eat() ]、睡觉 [ study() ] 等。 同一对象，由于侧重点不同可能会产生不同的抽象结果。 封装封装就是将抽象得到的数据和行为相组合，形成一个有机的整体——类，其中数据和函数(行为/功能)都是类的成员。 举例：将钟表封装成一个类。 1234567class Clock&#123; public: //外部接口，可在外部进行调用 void setTime(int newH,int newM,int newS); void showTime(); private: //私有成员，只能被内部方法所访问，外部无法直接访问 int hour,minute,second;&#125;; 封装使一部分成员作为外部接口，其他成员隐蔽起来，这样达到了对成员访问权限的合理控制，使不同类之间的相互影响减小到最低限度，增加数据的安全性。 继承思考：虽然对人进行了封装，但是人与人之间又是不同的，比如学生有学号、年级班级等数据以及青年大学习等行为，而老师有工号、讲师/教授/博导等称号以及教书育人等行为。这些不同对象拥有特有的数据和行为。 解决：C++提供一种类的继承的机制，允许程序员再保持原有类的特性的基础上，进行更具体、更详细的说明。 多态例如我们日常生活中所说的打架、打篮球、打酱油，虽然都是“打”，但是含义不同，动作不同。这就是多态性。重载函数就是一种多态的手段。 多态性是指一段程序能够处理多种类型对象的能力。 C++中，这种多态性可通过强制多态、重载多态、类型参数化多态、包含多态4种形式实现。 类和对象 类是对象的抽象，对象是类的实例。 类的声明先看一个栗子：下面是一个关于复数的类的定义： 123456789101112131415class Complex&#123; //关键字class声明名为Complex的类 double real; //数据成员，复数的实部 double imag; //数据成员，复数的虚部 // 成员函数 给数据成员赋初值 void init(double r,double i)&#123; real=r; imag=i; &#125; double abscomplex()&#123; double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; //注意这有个分号 类是一种数据类型，它是用户定义的一种抽象的数据类型。 编译下列代码： 123456int main()&#123; Complex A; // 定义类的对象 A.init(1.1, 2.2); // 调用类的init方法赋初值 cout&lt;&lt;\"复数的绝对值是：\"&lt;&lt;A.abscomplex()&lt;&lt;endl; return 0;&#125; 结果会出错： 错误之处在于，init()和abscomplex()是私有的。也就是说，在不说明类的成员是public(公有)还是private(私有)时，C++默认时私有的，也就是说外部不能直接访问。我们也可以看出，如果一个类中全部都是私有成员，那么这个类是没有任何用处的。 更改代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Complex&#123; // 关键字class声明名为Complex的类 private: //声明以下成员为私有 double real; //数据成员，复数的实部 double imag; //数据成员，复数的虚部 public: // 声明以下成员为共有 // 成员函数 给数据成员赋初值 void init(double r,double i)&#123; real=r; imag=i; &#125; double abscomplex()&#123; double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; //注意这有个分号int main()&#123; Complex A; // 定义类的对象 A.init(1.1, 2.2); // 调用类的init方法赋初值 cout&lt;&lt;\"复数的绝对值是：\"&lt;&lt;A.abscomplex()&lt;&lt;endl; // 调用abscomplex()方法求绝对值 return 0;&#125; 这样，外部就可以通过共有的方法简洁的访问类的成员。使得类内的私有成员变得更加安全。 运行结果： 说明：protected也是类成员的一个关键字，说明被保护成员，可由本类和派生类内的成员函数访问，其他访问是非法的。它是半隐蔽的。 成员函数的定义一般函数成员是公有的，习惯把共有成员写在前面，这样便于阅读。 在类内部定义函数(隐式声明)例如2.1中的例子一样定义函数就可以了。这种定义方式，C++编译器将函数作为内联函数处理。 在类外部定义函数首先要在类中声明函数原型，然后再在外部定义函数。 一般形式： 1234返回值类型 类名::成员函数名(参数表)&#123; 函数体&#125; 栗子： 123456789101112131415161718class Point&#123; public: void setpoint(int, int); // 声明成员函数 int getx(); // 声明函数 int gety(); // 声明函数 private: int x,y;&#125;;int Point::getx()&#123; return x;&#125;int Point::gety()&#123; return y;&#125;void Point::setpoint(int a, int b)&#123; x=a; y=b;&#125; 注意：Point::是必须写的。 采用这种定义方式是C++良好的类定义习惯，它可以减少类定义的长度，使阅读起来比较方便。 函数的显示定义就是在外部定义函数时，在函数最前面用inline声明成内联函数。 123inline int Point::getx()&#123; return x;&#125; 对象对象的定义定义一般形式： 123类名 对象1, 对象2, 对象3, ……;Point A,B; 类是一个模板，他不接收和存储数据，定义对象后，系统才会为对象分配对应的存储空间，用来存放对象总的成员。 对象中成员的访问通过对象选择符选择访问对象中的成员一般形式：对象名.数据成员或对象名.成员函数(实参表) 123Point op1;op1.setpoint(1,2); // 调用对象op1的成员函数给op1的数据成员赋值int i = op1.getx(); // 调用对象op1的成员函数取得x的值 通过指向对象的指针访问对象中的成员我们可以定义一个指针指向这个对象，则访问时使用-&gt;操作符： 1234567891011class Date&#123; public: int year;&#125;;int main()&#123; Date d, *p; // 定义了一个Date的对象的指针 p = &amp;d; // p指向对象d cout&lt;&lt; p-&gt;year &lt;&lt; endl;// 使用-&gt;访问成员year cout&lt;&lt; (*p).year &lt;&lt; endl; // 两者等价，因为*p就是对象d&#125; 通过引用访问对象成员1234567891011class Date&#123; public: int year;&#125;;int main()&#123; Date d; Date &amp;dd = d; // 定义d的引用 cout&lt;&lt;d.year; cout&lt;&lt;dd.year;&#125; dd是d的引用，所以dd与d占有相同的存储单元。 构造函数与析构函数在定义对象时，有时需要对数据成员进行初始化，这个任务由构造函数完成。 在特定对象使用结束后，还经常需要进行一些清理工作，这个任务由析构函数完成。 对象的初始化与构造函数类是一种抽象的数据类型，它不占存储空间，不能容纳具体数据，所以不能给数据成员赋初值。 所以下列程序是错误的。 1234class Date&#123; public: int year = 2019;&#125;; DEV-C++编译会出警告但是能运行，但是这种写法是错误的，最好不要使用，编程尽量按照规矩来，避免不同环境带来的奇怪的报错。 如果类种的所有成员都是共有的，则可以在定义对象时初始化数据成员。 1234567891011121314151617181920212223242526272829303132class Complex&#123; public: double real; double imag;&#125;;Complex c = &#123;1.1, 2.2&#125;;``` 如果成员是私有的，可以利用公有函数对对象中的数据成员赋初值：```c++class Complex&#123; public: void init(double ,double); double abscomplex(); private: double real; double imag;&#125;;void Complex::init(double a, duuble b)&#123; real = a; imag = b;&#125;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c; c.init(3.0, 4.0); cout&lt;&lt;c.abscomplex();&#125;// 运行结果：5 使用成员函数，给数据成员赋值，既不方便记忆也容易忘记，甚至会出错。所以，C++提供了构造函数来完成对象的初始化。 构造函数有以下特点： 必须与类同名 可以有任意类型的参数 不能具有返回值类型，void也不行 建立对象时自动执行 下面定义一个构造函数： 12345678910111213141516171819202122232425class Complex&#123; public: Complex(double r, double i)&#123; // 析构函数 real = r; imag = i; &#125; double abscomplex(); private: double real; double imag;&#125;;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c(3.0, 4.0); // 形式一 cout&lt;&lt; c.abscomplex() &lt;&lt; endl; Complex *p = new Complex(8.0,6.0); // 形式二 cout&lt;&lt; p-&gt;abscomplex() &lt;&lt;endl;&#125;/*运行结果：510*/ 将构造函数放在类外部定义： 123456789101112131415161718192021class Complex&#123; public: Complex(double r, double i); double abscomplex(); private: double real; double imag;&#125;;// 外部定义构造函数Complex::Complex(double r, double i)&#123; real = r; imag = i;&#125;double Complex::abscomplex()&#123; return sqrt(real*real + imag*imag);&#125;int main()&#123; Complex c(3.0, 4.0); cout&lt;&lt; c.abscomplex() &lt;&lt; endl;&#125;// 运行结构：5 在对构造函数做以下几点说明： 构造函数里面可以定义与初始化无关的操作，但是不提倡加入与初始化无关的操作。 构造函数一般声明为公有成员，但是它是在定义对象是自动调用的，而且只执行一次。像c.Complex(2.1,5.4)这种操作是非法的、错误的。 实际应用中，通常需要给每一个类都定义构造函数，如果没有定义的话，系统则会自动生成一个构造函数：Complex::Complex(){}。 可以没有形参。例如：Complex(){real = 0; image = 0;}。此时定义对象时Complex c，构造函数会被自动执行。 用成员初始化列表对数据成员初始化构造函数的另一种写法和调用方法。一般形式： 1234567构造函数名(形参表):数据成员1(初始化值1),数据成员2(初始化值2),……&#123; 构造函数体&#125;Complex(double r, double i):real(r), imag(i)&#123;&#125; 这种方法与普通的方法是有所区别的。普通构造函数是初始化数据成员是一种使用=的赋值操作，但是在C++中有些数据成员是不允许直接赋值的，例如const修饰的数据成员，或者是引用类型的数据成员，因此只能使用成员初始化列表对其初始化: 123456789101112131415161718192021222324252627class A&#123; public: A(int); // 声明原型函数 void print(); public: int x; int &amp;rx; const double pi; &#125;; A::A(int xx):x(xx), rx(x), pi(3.14)&#123;&#125; // 注意这里有一对花括号 void A::print()&#123; cout&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; cout&lt;&lt;\"rx=\"&lt;&lt;rx&lt;&lt;endl; cout&lt;&lt;\"pi=\"&lt;&lt;pi&lt;&lt;endl;&#125;int main()&#123; A a(7); a.print(); return 0;&#125;/*运行结果：x=7rx=7pi=3.14*/ 注意：使用该种方法初始化数据成员时，初始化顺序与成员初始化列表是没有关系的，是按照数据成员在类中声明的顺序初始化的。 123456789101112131415161718192021222324class A&#123; public: A(int); // 声明原型函数 void print(); public: int x; int y; &#125;; A::A(int xx):y(2*x),x(xx)&#123;&#125; // 注意这里有一对花括号 void A::print()&#123; cout&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl;&#125;int main()&#123; A a(7); a.print(); return 0;&#125;/*运行结果：x=7y=14*/ 建议使用成员初始化列表初始化数据成员，方便、简练。 构造函数的重载在C++，函数的重载是非常实用的，很多时候我们对不同的类型的数据进行相同的操作，就会用到重载。构造函数同样可以重载。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Date&#123; public: Date(); Date(int a, int b, int c); void print(); private: int year, month, day;&#125;; Date::Date():year(2019), month(12), day(3)&#123;&#125; // 初始化成默认数据Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2018, 12, 3); cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，初始成默认数据 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2018年12月3日d2: 2019年12月3日*/ 尽管一个类可以定义多个构造函数，但是创建一个对象时只会调用其中一个构造函数 带默认参数的构造函数构造函数允许带有默认参数，当创建对象时没有参数的传递就会使用默认参数。 12345678910111213141516171819202122232425262728class Date&#123; public: Date(int a=2018, int b=12, int c=3); //指定默认参数 void print(); private: int year, month, day;&#125;;// 在类外部创建构造函数时可以不再次指定默认参数值Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2019); // 调用时可以只指定部分参数 cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，使用默认参数 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2019年12月3日d2: 2018年12月3日*/ 说明： 一个类中如果定义了一个带有默认参数的构造函数，就不能再定义别的带有默认参数的构造函数或者是不带参数的构造函数。例如：Complex(double r=1.1, double i=2.2);Complex();如果存在这样两个构造函数的话，编译系统则不知道该调用哪个构造函数。 如下情况编译系统也无法判断应该调用哪个函数：Complex(double r=1.1, double i=2.2);Complex(double r); 析构函数析构函数执行与构造函数相反的操纵，通常用来执行一些清洗工作，如释放分配给对象的空间等。它有以下特点： 析构函数名与类名相同 析构函数不具有任何返回值，不能说明它的类型 析构函数没有参数，不能重载 撤销对象时，系统自动调用析构函数 123456789101112131415161718192021222324252627282930313233class Date&#123; public: Date(int a=2018, int b=12, int c=3); //带有默认参数 ~Date(); //声明析构函数 void print(); private: int year, month, day;&#125;;Date::~Date()&#123; // 析构函数 内部可以写程序体 cout&lt;&lt;\"清洗完毕\"&lt;&lt;endl; &#125;Date::Date(int a, int b, int c):year(a), month(b), day(c)&#123;&#125;void Date::print()&#123; cout&lt;&lt;year&lt;&lt;\"年\"&lt;&lt;month&lt;&lt;\"月\"&lt;&lt;day&lt;&lt;\"日\"&lt;&lt;endl; &#125;int main()&#123; Date d1(2019); cout&lt;&lt;\"d1: \"; d1.print(); Date d2; // 没有参数，使用默认参数 cout&lt;&lt;\"d2: \"; d2.print();&#125;/*运行结果：d1: 2019年12月3日d2: 2018年12月3日清洗完毕清洗完毕*/ 可以看出，当对象的生命周期结束时，系统将自动调用析构函数，清洗对象的存储空间。 如果没有定义析构函数，系统会默认定义Date::~Date(){}作为类的析构函数。一般情况下系统自动定义的析构函数足以满足需要。 但是，当在清理对象之前还需要做一些操作的话，则需要自己定义析构函数。","categories":[{"name":"编程语言","slug":"programming-languages","permalink":"http://yoursite.com/categories/programming-languages/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"类与对象","slug":"class-object","permalink":"http://yoursite.com/tags/class-object/"}]},{"title":"慕课评论爬虫","slug":"慕课评论爬虫","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-27T13:04:42.986Z","comments":true,"path":"2019/11/21/慕课评论爬虫/","link":"","permalink":"http://yoursite.com/2019/11/21/%E6%85%95%E8%AF%BE%E8%AF%84%E8%AE%BA%E7%88%AC%E8%99%AB/","excerpt":"看文件看到了今年暑假写的爬虫代码，当时要做数据分析才去学的爬虫。本来对爬虫挺好奇的，但是学了一点之后就没什么兴趣了，特别是看scrapy爬虫框架，我看了连两天没有看明白，笨拙的我果断放弃了scrapy。对于那些动态网页，我就直接采用selenium进行网页加载和模拟点击翻页操作，虽然速度慢，但是对我来说可以问题不大。 毕竟咱也不是做爬虫的，用的时候能爬出来数据就好了。","text":"看文件看到了今年暑假写的爬虫代码，当时要做数据分析才去学的爬虫。本来对爬虫挺好奇的，但是学了一点之后就没什么兴趣了，特别是看scrapy爬虫框架，我看了连两天没有看明白，笨拙的我果断放弃了scrapy。对于那些动态网页，我就直接采用selenium进行网页加载和模拟点击翻页操作，虽然速度慢，但是对我来说可以问题不大。 毕竟咱也不是做爬虫的，用的时候能爬出来数据就好了。 今天看到以前写的代码，觉得以后可能会需要用到爬虫爬点数据啥的，所以有必要把代码保留好，毕竟两个月没写过爬虫我都忘了怎么写的了。爬的是慕课上面一门课程的评论： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import timeimport reimport pandas as pdfrom bs4 import BeautifulSoupfrom selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Bydef comment(url,n): driver=webdriver.PhantomJS() driver.get(url) soup=BeautifulSoup(driver.page_source,'lxml') # 点击‘课程评价’ evaluation_click=WebDriverWait(driver,10).until(EC.element_to_be_clickable((By.CSS_SELECTOR,'#review-tag-button'))) evaluation_click.click() # 等待加载评论 time.sleep(2) soup=BeautifulSoup(driver.page_source,'lxml') # 抓取课程总评分 score=soup.select('div.ux-mooc-comment-course-comment_head_rating-scores &gt; span')[0].text print('课程总评分：',score) # 抓取评论人数 comment_number=re.findall('\\d+',soup.select('#review-tag-num')[0].text)[0] print('评论次数',comment_number) print('------------------------') comments=[] # 评论 points = [] # 评分 p_time = [] # 发表时间 c_time = [] # 对应课时 like_num=[] # 点赞人数 stu_id = [] # 抓取单独个人的评价内容、评分、评论点赞数、发布时间、对应课时 # --------------------------循环开始---------------------------- for n in range(1,n+1): # 抓取学生id stu_name=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_user-info &gt; a') stu_id.append([re.findall('\\d+',x.get('href'))[1] for x in stu_name]) # 爬取评论内容 comment=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_content &gt; span') list_=[] for k in comment: list_.append(k.text) comments.append(list_) # 爬取发表时间 public_time=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_time') list_=[] for k in public_time: list_.append(k.text) p_time.append(list_) # 爬取评论对应开课次数 class_time=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_term-sign') list_=[] for k in class_time: list_.append(k.text) c_time.append(list_) # 爬取点赞次数 like_number=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info &gt; div.ux-mooc-comment-course-comment_comment-list_item_body_comment-info_actions &gt; span &gt; span &gt; span:nth-of-type(2)') list_=[] for k in like_number: list_.append(k.text) like_num.append(list_) # 抓取评分 goal=soup.select('div.ux-mooc-comment-course-comment_comment-list_item_body_user-info &gt; span &gt; div &gt; div.star-point') point_list=[] for i in goal: point_list.append(len(i.select('i'))) points.append(point_list) # 点击‘下一页’，继续加载评论内容 next_page=WebDriverWait(driver,10).until(EC.element_to_be_clickable((By.CSS_SELECTOR,'li.ux-pager_btn.ux-pager_btn__next &gt; a'))) next_page.click() # 模拟点击与解析页面之间添加sleep，避免爬去重复页面 time.sleep(2) # 解析当前页面 soup=BeautifulSoup(driver.page_source,'lxml') print('已爬取%d页内容！'%n) # -----------------------结束循环----------------------- driver.close() # 整理所得结果，使之成为一维列表 points=[x for i in points for x in i] like_num=[x for i in like_num for x in i] c_time=[x for i in c_time for x in i] p_time=[x for i in p_time for x in i] comments=[x for i in comments for x in i if x!='更多'] stu_id=[x for i in stu_id for x in i] # 存储结果为DataFrame形式 return pd.DataFrame(&#123; '学生ID':stu_id, '评论':comments, '评分':points, '发布时间':p_time, '对应课时':c_time, '点赞人数':like_num &#125;)url='https://www.icourse163.org/course/BIT-1001870001'n=85df=comment(url,n) 结果：","categories":[{"name":"爬虫","slug":"crawler","permalink":"http://yoursite.com/categories/crawler/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"crawler","permalink":"http://yoursite.com/tags/crawler/"}]},{"title":"分治算法-棋盘覆盖问题","slug":"分治算法-棋盘覆盖问题","date":"2019-11-15T16:00:00.000Z","updated":"2019-12-21T15:25:37.222Z","comments":true,"path":"2019/11/16/分治算法-棋盘覆盖问题/","link":"","permalink":"http://yoursite.com/2019/11/16/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/","excerpt":"最近老师给我们布置了一道OJ题目，是关于分治算法的，觉得很有意思，也自己琢磨出了解题代码，就来记录一下。","text":"最近老师给我们布置了一道OJ题目，是关于分治算法的，觉得很有意思，也自己琢磨出了解题代码，就来记录一下。 题目题目: 分治思路直接看这篇文章就好了，有图可以帮助理解。 代码代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;int qp[64][64];int qz=1;void fun(int th,int tl,int qh,int jh,int qsl,int jzl)&#123; // th/tl-特殊位置 qh/jh-起始行/截至行 qsl/jzl-起始列/截至列 int zsh,zsl,ysh,ysl,zxh,zxl,yxh,yxl; //记录每个分治的特殊位置：左上 右上 左下 右下 float x,y; //坐标原点 x=float(qh+jh)/2; y=float(qsl+jzl)/2; //判断特殊点在第几象限 if(float(th)&lt;x &amp;&amp; float(tl)&lt;y)&#123; //第一象限 左上 qp[int(x+0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qp[int(x-0.5)][int(y+0.5)]=qz++; //记录每个分治的特殊位置 zsh=th;zsl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zxh=int(x+0.5);zxl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&lt;x &amp;&amp; float(tl)&gt;y)&#123; //第二象限 右上 qp[int(x-0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qp[int(x+0.5)][int(y-0.5)]=qz++; ysh=th;ysl=tl; zsh=int(x-0.5);zsl=int(y-0.5); zxh=int(x+0.5);zxl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&gt;x &amp;&amp; float(tl)&lt;y)&#123; //第三象限 左下 qp[int(x-0.5)][int(y+0.5)]=qp[int(x-0.5)][int(y-0.5)]=qp[int(x+0.5)][int(y+0.5)]=qz++; zxh=th;zxl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zsh=int(x-0.5);zsl=int(y-0.5); yxh=int(x+0.5);yxl=int(y+0.5); &#125; else if(float(th)&gt;x &amp;&amp; float(tl)&gt;y)&#123; //第四象限 右下 qp[int(x+0.5)][int(y-0.5)]=qp[int(x-0.5)][int(y-0.5)]=qp[int(x-0.5)][int(y+0.5)]=qz++; yxh=th;yxl=tl; ysh=int(x-0.5);ysl=int(y+0.5); zxh=int(x+0.5);zxl=int(y-0.5); zsh=int(x-0.5);zsl=int(y-0.5); &#125; if(qh+1==jh) return; //分治结束 //递归左上分治 fun(zsh,zsl,qh,(qh+jh)/2,qsl,(qsl+jzl)/2); //递归右上分治 fun(ysh,ysl,qh,(qh+jh)/2,(qsl+jzl)/2+1,jzl); //递归左下分治 fun(zxh,zxl,(qh+jh)/2+1,jh,qsl,(qsl+jzl)/2); //递归右下分治 fun(yxh,yxl,(qh+jh)/2+1,jh,(qsl+jzl)/2+1,jzl);&#125; int main()&#123; int N,n,row,col,i,j,k=1; cin&gt;&gt;N; while(N--)&#123; qz=1; cin&gt;&gt;n&gt;&gt;row&gt;&gt;col; fun(row,col,0,n-1,0,n-1); cout&lt;&lt;\"CASE:\"&lt;&lt;k++&lt;&lt;\"\\n\"; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(j!=n-1) cout&lt;&lt;qp[i][j]&lt;&lt;\"\\t\"; else cout&lt;&lt;qp[i][j]; &#125; cout&lt;&lt;\"\\n\"; &#125; &#125;&#125; 再放两个别人的代码： 因为我头脑简单，所以觉得自己的代码比别人的好懂(没人家的高级，嘿嘿)。以下别人的代码来自这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;int tile=1; //L型骨牌的编号(递增)int board[100][100]; //棋盘/****************************************************** 递归方式实现棋盘覆盖算法* 输入参数：* tr--当前棋盘左上角的行号* tc--当前棋盘左上角的列号* dr--当前特殊方格所在的行号* dc--当前特殊方格所在的列号* size：当前棋盘的:2^k*****************************************************/void chessBoard ( int tr, int tc, int dr, int dc, int size )&#123; if ( size==1 ) //棋盘方格大小为1,说明递归到最里层 return; int t=tile++; //每次递增1 int s=size/2; //棋盘中间的行、列号(相等的) //检查特殊方块是否在左上角子棋盘中 if ( dr&lt;tr+s &amp;&amp; dc&lt;tc+s ) //在 chessBoard ( tr, tc, dr, dc, s ); else //不在，将该子棋盘右下角的方块视为特殊方块 &#123; board[tr+s-1][tc+s-1]=t; chessBoard ( tr, tc, tr+s-1, tc+s-1, s ); &#125; //检查特殊方块是否在右上角子棋盘中 if ( dr&lt;tr+s &amp;&amp; dc&gt;=tc+s ) //在 chessBoard ( tr, tc+s, dr, dc, s ); else //不在，将该子棋盘左下角的方块视为特殊方块 &#123; board[tr+s-1][tc+s]=t; chessBoard ( tr, tc+s, tr+s-1, tc+s, s ); &#125; //检查特殊方块是否在左下角子棋盘中 if ( dr&gt;=tr+s &amp;&amp; dc&lt;tc+s ) //在 chessBoard ( tr+s, tc, dr, dc, s ); else //不在，将该子棋盘右上角的方块视为特殊方块 &#123; board[tr+s][tc+s-1]=t; chessBoard ( tr+s, tc, tr+s, tc+s-1, s ); &#125; //检查特殊方块是否在右下角子棋盘中 if ( dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s ) //在 chessBoard ( tr+s, tc+s, dr, dc, s ); else //不在，将该子棋盘左上角的方块视为特殊方块 &#123; board[tr+s][tc+s]=t; chessBoard ( tr+s, tc+s, tr+s, tc+s, s ); &#125;&#125;void main()&#123; int size; cout&lt;&lt;\"输入棋盘的size(大小必须是2的n次幂): \"; cin&gt;&gt;size; int index_x,index_y; cout&lt;&lt;\"输入特殊方格位置的坐标: \"; cin&gt;&gt;index_x&gt;&gt;index_y; chessBoard ( 0,0,index_x,index_y,size ); for ( int i=0; i&lt;size; i++ ) &#123; for ( int j=0; j&lt;size; j++ ) cout&lt;&lt;board[i][j]&lt;&lt;\"/t\"; cout&lt;&lt;endl; &#125;&#125; 2. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;const int N = 11;int Board[N][N];int tile = 0; /*tr:棋盘左上角方格的行号tc:棋盘左上角方格的列号dr:特殊方格所在的行号dc:特殊方格所在的列号size:方形棋盘的边长*/void ChessBoard(int tr, int tc, int dr, int dc, int size)&#123; if(size == 1) return; int t = ++tile, s = size/2; //覆盖左上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s) //特殊方格在此棋盘中 ChessBoard(tr, tc, dr, dc, s); else // 此棋盘无特殊方格 &#123; // 用t号L型骨型牌覆盖右下角 Board[tr+s-1][tc+s-1] = t; // 覆盖其余方格 ChessBoard(tr, tc, tr+s-1, tc+s-1, s); &#125; //覆盖右上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&gt;=tc+s) ChessBoard(tr, tc+s, dr, dc, s); else &#123; Board[tr+s-1][tc+s] = t; ChessBoard(tr, tc+s, tr+s-1, tc+s, s); &#125; //覆盖左下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&lt;tc+s) ChessBoard(tr+s, tc, dr, dc, s); else &#123; Board[tr+s][tc+s-1] = t; ChessBoard(tr+s, tc, tr+s, tc+s-1, s); &#125; //覆盖右下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s) ChessBoard(tr+s, tc+s, dr, dc, s); else &#123; Board[tr+s][tc+s] = t; ChessBoard(tr+s, tc+s, tr+s, tc+s, s); &#125;&#125; void DisplayBoard(int size)&#123; for(int i=1; i&lt;=size; ++i) &#123; for(int j=1; j&lt;=size; ++j) printf(\"%2d \", Board[i][j]); printf(\"\\n\"); &#125;&#125; int main()&#123; ChessBoard(1, 1, 1, 2, 4); DisplayBoard(4); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"分治算法","slug":"fenzhi","permalink":"http://yoursite.com/tags/fenzhi/"},{"name":"棋盘覆盖","slug":"qipanfugai","permalink":"http://yoursite.com/tags/qipanfugai/"},{"name":"数据结构","slug":"DataStructure","permalink":"http://yoursite.com/tags/DataStructure/"}]},{"title":"TensorFlow2.0图片数据读取","slug":"TensorFlow2.0读取图片数据","date":"2019-11-14T16:00:00.000Z","updated":"2019-12-02T04:50:01.069Z","comments":true,"path":"2019/11/15/TensorFlow2.0读取图片数据/","link":"","permalink":"http://yoursite.com/2019/11/15/TensorFlow2.0%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE/","excerpt":"最近TensorFlow2.0正式发布，而且把Keras合并成为了TensorFlow2.0的一个高级API，这操作简直是爽啊。然后我就屁跌儿屁跌儿的去学TensorFlow了，想着搭建一个图片分类器玩玩。调用tf.Keras简直不要太爽啊，搭好神经网络之后我开始读点图片测试程序能不能跑通。刚打开文件我才意识到，读图片跟读文本、表格不一样，我就赶紧看TensorFlow2.0的中文文档还有其他百度的方法，这一看就是三四天，太折磨人了。","text":"最近TensorFlow2.0正式发布，而且把Keras合并成为了TensorFlow2.0的一个高级API，这操作简直是爽啊。然后我就屁跌儿屁跌儿的去学TensorFlow了，想着搭建一个图片分类器玩玩。调用tf.Keras简直不要太爽啊，搭好神经网络之后我开始读点图片测试程序能不能跑通。刚打开文件我才意识到，读图片跟读文本、表格不一样，我就赶紧看TensorFlow2.0的中文文档还有其他百度的方法，这一看就是三四天，太折磨人了。 最后我放弃了文档和百度，自己看tf自带的数据集加载之后的type和shape，然后我发现图片数据加载完之后的类型是array形状是(60000,28,28),形状的是一个四维向量，分别是：(样本量，图片长度，图片宽度，图片通道数)，因为我看的是Mnist数据集，它的图片是一个channels=1的图片，所以shape没有最后第四维。通过观察这些特征之后我就自己使用numpy、os库自己尝试着把数据加载组合成这样的type和shape，代码如下： 12345678910111213141516171819202122232425262728293031# 加载图片def imgfun(fn): image_string = tf.io.read_file(fn) image_decoded = tf.image.decode_jpeg(image_string,channels=3) image_resized = tf.image.resize(image_decoded, [200, 200]) / 255.0 image = np.array(image_resized).tolist() return image# 处理图片def process_img(pdir_1,pdir_2,n1,n2): pathdir_1 = os.listdir(pdir_1) # 根目录 pathdir_2 = os.listdir(pdir_2) # 路径合并 paths = [pdir_1 + path for path in pathdir_1] paths.extend([pdir_2 + path for path in pathdir_2]) # 合并形成完整图片路径 # 添加标签 labels = [n1]*len(pathdir_1) # label n1 stand for 1 labels.extend([n2]*len(pathdir_2)) # label n2 stand for 2 # 打乱数据集 img_data = zip(paths,labels) # 合并路径和标签 img_data = np.array(list(img_data)) # np.array型可调用shuffle方法进行打乱 np.random.shuffle(img_data) # 打乱 path = [x[0] for x in img_data] # 提取图片路径 label = np.array([x[1] for x in img_data],dtype=int) # 提取对应的图片标签，标签为int类型 img = np.array(list(map(imgfun,path))) # 调用imgfun函数提取图片数据并转化成array形式 return img,label 上述代码运行结果： 在上面代码中我遇到一个map函数，刚开始发现它返回的是一个迭代器类型，我遍历一遍之后再次遍历发现就没有输出结果了，我百度之后get到了一个新的知识点： map函数在python.2.xxx中返回的是一个列表，在python.3.xxx中返回的是一个迭代器。迭代器遍历一次之后里面的元素就没有了。 就像这样：","categories":[{"name":"深度学习","slug":"deep-learning","permalink":"http://yoursite.com/categories/deep-learning/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"深度学习","slug":"deep-learning","permalink":"http://yoursite.com/tags/deep-learning/"},{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"http://yoursite.com/tags/TensorFlow2-0/"},{"name":"图像","slug":"image","permalink":"http://yoursite.com/tags/image/"},{"name":"数据读取","slug":"readdata","permalink":"http://yoursite.com/tags/readdata/"}]}]}